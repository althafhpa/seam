var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SeamHttpInvalidInputError_validationErrors;
export class SeamHttpApiError extends Error {
    constructor(error, statusCode, requestId) {
        const { type, message, data } = error;
        super(message);
        this.name = this.constructor.name;
        this.code = type;
        this.statusCode = statusCode;
        this.requestId = requestId;
        if (data != null)
            this.data = data;
    }
}
export const isSeamHttpApiError = (error) => {
    return error instanceof SeamHttpApiError;
};
export class SeamHttpUnauthorizedError extends SeamHttpApiError {
    constructor(requestId) {
        const type = 'unauthorized';
        const status = 401;
        super({ type, message: 'Unauthorized' }, status, requestId);
        this.name = this.constructor.name;
        this.code = type;
        this.statusCode = status;
        this.requestId = requestId;
    }
}
export const isSeamHttpUnauthorizedError = (error) => {
    return error instanceof SeamHttpUnauthorizedError;
};
export class SeamHttpInvalidInputError extends SeamHttpApiError {
    constructor(error, statusCode, requestId) {
        super(error, statusCode, requestId);
        _SeamHttpInvalidInputError_validationErrors.set(this, void 0);
        this.name = this.constructor.name;
        this.code = 'invalid_input';
        __classPrivateFieldSet(this, _SeamHttpInvalidInputError_validationErrors, error.validation_errors ?? {}, "f");
    }
    getValidationErrorMessages(paramName) {
        return __classPrivateFieldGet(this, _SeamHttpInvalidInputError_validationErrors, "f")[paramName]?._errors ?? [];
    }
}
_SeamHttpInvalidInputError_validationErrors = new WeakMap();
export const isSeamHttpInvalidInputError = (error) => {
    return error instanceof SeamHttpInvalidInputError;
};
//# sourceMappingURL=seam-http-error.js.map