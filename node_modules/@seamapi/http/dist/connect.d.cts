import { RouteRequestBody, RouteResponse, ActionAttempt, openapi } from '@seamapi/types/connect';
import { AxiosInstance, AxiosRequestConfig, Method } from 'axios';
import { AxiosRetry } from 'axios-retry';
export * from '@seamapi/url-search-params-serializer';

type Client = AxiosInstance;
interface ClientOptions {
    axiosOptions?: AxiosRequestConfig;
    axiosRetryOptions?: AxiosRetryConfig;
}
type AxiosRetryConfig = Parameters<AxiosRetry>[1];

interface SeamHttpRequestParent {
    readonly client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
}
interface SeamHttpRequestConfig<TResponseKey> {
    readonly path: string;
    readonly method: Method;
    readonly body?: unknown;
    readonly params?: undefined | Record<string, unknown>;
    readonly responseKey: TResponseKey;
    readonly options?: Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>;
}
declare class SeamHttpRequest<const TResponse, const TResponseKey extends keyof TResponse | undefined> implements Promise<TResponseKey extends keyof TResponse ? TResponse[TResponseKey] : undefined> {
    #private;
    readonly [Symbol.toStringTag]: string;
    constructor(parent: SeamHttpRequestParent, config: SeamHttpRequestConfig<TResponseKey>);
    get responseKey(): TResponseKey;
    get url(): URL;
    get method(): Method;
    get body(): unknown;
    execute(): Promise<TResponseKey extends keyof TResponse ? TResponse[TResponseKey] : undefined>;
    then<TResult1 = TResponseKey extends keyof TResponse ? TResponse[TResponseKey] : undefined, TResult2 = never>(onfulfilled?: ((value: TResponseKey extends keyof TResponse ? TResponse[TResponseKey] : undefined) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined): Promise<TResult1 | TResult2>;
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null | undefined): Promise<(TResponseKey extends keyof TResponse ? TResponse[TResponseKey] : undefined) | TResult>;
    finally(onfinally?: (() => void) | null | undefined): Promise<TResponseKey extends keyof TResponse ? TResponse[TResponseKey] : undefined>;
}

type SetNonNullable<BaseType, Keys extends keyof BaseType = keyof BaseType> = {
    [Key in keyof BaseType]: Key extends Keys ? NonNullable<BaseType[Key]> : BaseType[Key];
};

declare class SeamHttpAccessCodesSimulate {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpAccessCodesSimulate;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpAccessCodesSimulate;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpAccessCodesSimulate;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpAccessCodesSimulate>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpAccessCodesSimulate;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpAccessCodesSimulate;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    createUnmanagedAccessCode(body?: AccessCodesSimulateCreateUnmanagedAccessCodeBody): SeamHttpRequest<AccessCodesSimulateCreateUnmanagedAccessCodeResponse, 'access_code'>;
}
type AccessCodesSimulateCreateUnmanagedAccessCodeBody = RouteRequestBody<'/access_codes/simulate/create_unmanaged_access_code'>;
type AccessCodesSimulateCreateUnmanagedAccessCodeResponse = SetNonNullable<Required<RouteResponse<'/access_codes/simulate/create_unmanaged_access_code'>>>;
type AccessCodesSimulateCreateUnmanagedAccessCodeOptions = never;

declare class SeamHttpAccessCodesUnmanaged {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpAccessCodesUnmanaged;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpAccessCodesUnmanaged;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpAccessCodesUnmanaged;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpAccessCodesUnmanaged>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpAccessCodesUnmanaged;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpAccessCodesUnmanaged;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    convertToManaged(body?: AccessCodesUnmanagedConvertToManagedBody): SeamHttpRequest<void, undefined>;
    delete(body?: AccessCodesUnmanagedDeleteParams): SeamHttpRequest<void, undefined>;
    get(body?: AccessCodesUnmanagedGetParams): SeamHttpRequest<AccessCodesUnmanagedGetResponse, 'access_code'>;
    list(body?: AccessCodesUnmanagedListParams): SeamHttpRequest<AccessCodesUnmanagedListResponse, 'access_codes'>;
    update(body?: AccessCodesUnmanagedUpdateBody): SeamHttpRequest<void, undefined>;
}
type AccessCodesUnmanagedConvertToManagedBody = RouteRequestBody<'/access_codes/unmanaged/convert_to_managed'>;
type AccessCodesUnmanagedConvertToManagedResponse = SetNonNullable<Required<RouteResponse<'/access_codes/unmanaged/convert_to_managed'>>>;
type AccessCodesUnmanagedConvertToManagedOptions = never;
type AccessCodesUnmanagedDeleteParams = RouteRequestBody<'/access_codes/unmanaged/delete'>;
type AccessCodesUnmanagedDeleteResponse = SetNonNullable<Required<RouteResponse<'/access_codes/unmanaged/delete'>>>;
type AccessCodesUnmanagedDeleteOptions = never;
type AccessCodesUnmanagedGetParams = RouteRequestBody<'/access_codes/unmanaged/get'>;
type AccessCodesUnmanagedGetResponse = SetNonNullable<Required<RouteResponse<'/access_codes/unmanaged/get'>>>;
type AccessCodesUnmanagedGetOptions = never;
type AccessCodesUnmanagedListParams = RouteRequestBody<'/access_codes/unmanaged/list'>;
type AccessCodesUnmanagedListResponse = SetNonNullable<Required<RouteResponse<'/access_codes/unmanaged/list'>>>;
type AccessCodesUnmanagedListOptions = never;
type AccessCodesUnmanagedUpdateBody = RouteRequestBody<'/access_codes/unmanaged/update'>;
type AccessCodesUnmanagedUpdateResponse = SetNonNullable<Required<RouteResponse<'/access_codes/unmanaged/update'>>>;
type AccessCodesUnmanagedUpdateOptions = never;

declare class SeamHttpAccessCodes {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpAccessCodes;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpAccessCodes;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpAccessCodes;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpAccessCodes>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpAccessCodes;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpAccessCodes;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    get unmanaged(): SeamHttpAccessCodesUnmanaged;
    get simulate(): SeamHttpAccessCodesSimulate;
    create(body?: AccessCodesCreateBody): SeamHttpRequest<AccessCodesCreateResponse, 'access_code'>;
    createMultiple(body?: AccessCodesCreateMultipleBody): SeamHttpRequest<AccessCodesCreateMultipleResponse, 'access_codes'>;
    delete(body?: AccessCodesDeleteParams): SeamHttpRequest<void, undefined>;
    generateCode(body?: AccessCodesGenerateCodeBody): SeamHttpRequest<AccessCodesGenerateCodeResponse, 'generated_code'>;
    get(body?: AccessCodesGetParams): SeamHttpRequest<AccessCodesGetResponse, 'access_code'>;
    list(body?: AccessCodesListParams): SeamHttpRequest<AccessCodesListResponse, 'access_codes'>;
    pullBackupAccessCode(body?: AccessCodesPullBackupAccessCodeBody): SeamHttpRequest<AccessCodesPullBackupAccessCodeResponse, 'backup_access_code'>;
    update(body?: AccessCodesUpdateBody): SeamHttpRequest<void, undefined>;
}
type AccessCodesCreateBody = RouteRequestBody<'/access_codes/create'>;
type AccessCodesCreateResponse = SetNonNullable<Required<RouteResponse<'/access_codes/create'>>>;
type AccessCodesCreateOptions = never;
type AccessCodesCreateMultipleBody = RouteRequestBody<'/access_codes/create_multiple'>;
type AccessCodesCreateMultipleResponse = SetNonNullable<Required<RouteResponse<'/access_codes/create_multiple'>>>;
type AccessCodesCreateMultipleOptions = never;
type AccessCodesDeleteParams = RouteRequestBody<'/access_codes/delete'>;
type AccessCodesDeleteResponse = SetNonNullable<Required<RouteResponse<'/access_codes/delete'>>>;
type AccessCodesDeleteOptions = never;
type AccessCodesGenerateCodeBody = RouteRequestBody<'/access_codes/generate_code'>;
type AccessCodesGenerateCodeResponse = SetNonNullable<Required<RouteResponse<'/access_codes/generate_code'>>>;
type AccessCodesGenerateCodeOptions = never;
type AccessCodesGetParams = RouteRequestBody<'/access_codes/get'>;
type AccessCodesGetResponse = SetNonNullable<Required<RouteResponse<'/access_codes/get'>>>;
type AccessCodesGetOptions = never;
type AccessCodesListParams = RouteRequestBody<'/access_codes/list'>;
type AccessCodesListResponse = SetNonNullable<Required<RouteResponse<'/access_codes/list'>>>;
type AccessCodesListOptions = never;
type AccessCodesPullBackupAccessCodeBody = RouteRequestBody<'/access_codes/pull_backup_access_code'>;
type AccessCodesPullBackupAccessCodeResponse = SetNonNullable<Required<RouteResponse<'/access_codes/pull_backup_access_code'>>>;
type AccessCodesPullBackupAccessCodeOptions = never;
type AccessCodesUpdateBody = RouteRequestBody<'/access_codes/update'>;
type AccessCodesUpdateResponse = SetNonNullable<Required<RouteResponse<'/access_codes/update'>>>;
type AccessCodesUpdateOptions = never;

declare class SeamHttpAcsAccessGroupsUnmanaged {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpAcsAccessGroupsUnmanaged;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpAcsAccessGroupsUnmanaged;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpAcsAccessGroupsUnmanaged;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpAcsAccessGroupsUnmanaged>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpAcsAccessGroupsUnmanaged;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpAcsAccessGroupsUnmanaged;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    get(body?: AcsAccessGroupsUnmanagedGetParams): SeamHttpRequest<AcsAccessGroupsUnmanagedGetResponse, 'acs_access_group'>;
    list(body?: AcsAccessGroupsUnmanagedListParams): SeamHttpRequest<AcsAccessGroupsUnmanagedListResponse, 'acs_access_groups'>;
}
type AcsAccessGroupsUnmanagedGetParams = RouteRequestBody<'/acs/access_groups/unmanaged/get'>;
type AcsAccessGroupsUnmanagedGetResponse = SetNonNullable<Required<RouteResponse<'/acs/access_groups/unmanaged/get'>>>;
type AcsAccessGroupsUnmanagedGetOptions = never;
type AcsAccessGroupsUnmanagedListParams = RouteRequestBody<'/acs/access_groups/unmanaged/list'>;
type AcsAccessGroupsUnmanagedListResponse = SetNonNullable<Required<RouteResponse<'/acs/access_groups/unmanaged/list'>>>;
type AcsAccessGroupsUnmanagedListOptions = never;

declare class SeamHttpAcsAccessGroups {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpAcsAccessGroups;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpAcsAccessGroups;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpAcsAccessGroups;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpAcsAccessGroups>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpAcsAccessGroups;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpAcsAccessGroups;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    get unmanaged(): SeamHttpAcsAccessGroupsUnmanaged;
    addUser(body?: AcsAccessGroupsAddUserBody): SeamHttpRequest<void, undefined>;
    get(body?: AcsAccessGroupsGetParams): SeamHttpRequest<AcsAccessGroupsGetResponse, 'acs_access_group'>;
    list(body?: AcsAccessGroupsListParams): SeamHttpRequest<AcsAccessGroupsListResponse, 'acs_access_groups'>;
    listAccessibleEntrances(body?: AcsAccessGroupsListAccessibleEntrancesParams): SeamHttpRequest<AcsAccessGroupsListAccessibleEntrancesResponse, 'acs_entrances'>;
    listUsers(body?: AcsAccessGroupsListUsersParams): SeamHttpRequest<AcsAccessGroupsListUsersResponse, 'acs_users'>;
    removeUser(body?: AcsAccessGroupsRemoveUserParams): SeamHttpRequest<void, undefined>;
}
type AcsAccessGroupsAddUserBody = RouteRequestBody<'/acs/access_groups/add_user'>;
type AcsAccessGroupsAddUserResponse = SetNonNullable<Required<RouteResponse<'/acs/access_groups/add_user'>>>;
type AcsAccessGroupsAddUserOptions = never;
type AcsAccessGroupsGetParams = RouteRequestBody<'/acs/access_groups/get'>;
type AcsAccessGroupsGetResponse = SetNonNullable<Required<RouteResponse<'/acs/access_groups/get'>>>;
type AcsAccessGroupsGetOptions = never;
type AcsAccessGroupsListParams = RouteRequestBody<'/acs/access_groups/list'>;
type AcsAccessGroupsListResponse = SetNonNullable<Required<RouteResponse<'/acs/access_groups/list'>>>;
type AcsAccessGroupsListOptions = never;
type AcsAccessGroupsListAccessibleEntrancesParams = RouteRequestBody<'/acs/access_groups/list_accessible_entrances'>;
type AcsAccessGroupsListAccessibleEntrancesResponse = SetNonNullable<Required<RouteResponse<'/acs/access_groups/list_accessible_entrances'>>>;
type AcsAccessGroupsListAccessibleEntrancesOptions = never;
type AcsAccessGroupsListUsersParams = RouteRequestBody<'/acs/access_groups/list_users'>;
type AcsAccessGroupsListUsersResponse = SetNonNullable<Required<RouteResponse<'/acs/access_groups/list_users'>>>;
type AcsAccessGroupsListUsersOptions = never;
type AcsAccessGroupsRemoveUserParams = RouteRequestBody<'/acs/access_groups/remove_user'>;
type AcsAccessGroupsRemoveUserResponse = SetNonNullable<Required<RouteResponse<'/acs/access_groups/remove_user'>>>;
type AcsAccessGroupsRemoveUserOptions = never;

declare class SeamHttpAcsCredentialPools {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpAcsCredentialPools;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpAcsCredentialPools;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpAcsCredentialPools;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpAcsCredentialPools>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpAcsCredentialPools;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpAcsCredentialPools;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    list(body?: AcsCredentialPoolsListParams): SeamHttpRequest<AcsCredentialPoolsListResponse, 'acs_credential_pools'>;
}
type AcsCredentialPoolsListParams = RouteRequestBody<'/acs/credential_pools/list'>;
type AcsCredentialPoolsListResponse = SetNonNullable<Required<RouteResponse<'/acs/credential_pools/list'>>>;
type AcsCredentialPoolsListOptions = never;

declare class SeamHttpAcsCredentialProvisioningAutomations {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpAcsCredentialProvisioningAutomations;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpAcsCredentialProvisioningAutomations;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpAcsCredentialProvisioningAutomations;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpAcsCredentialProvisioningAutomations>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpAcsCredentialProvisioningAutomations;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpAcsCredentialProvisioningAutomations;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    launch(body?: AcsCredentialProvisioningAutomationsLaunchBody): SeamHttpRequest<AcsCredentialProvisioningAutomationsLaunchResponse, 'acs_credential_provisioning_automation'>;
}
type AcsCredentialProvisioningAutomationsLaunchBody = RouteRequestBody<'/acs/credential_provisioning_automations/launch'>;
type AcsCredentialProvisioningAutomationsLaunchResponse = SetNonNullable<Required<RouteResponse<'/acs/credential_provisioning_automations/launch'>>>;
type AcsCredentialProvisioningAutomationsLaunchOptions = never;

declare class SeamHttpAcsCredentialsUnmanaged {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpAcsCredentialsUnmanaged;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpAcsCredentialsUnmanaged;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpAcsCredentialsUnmanaged;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpAcsCredentialsUnmanaged>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpAcsCredentialsUnmanaged;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpAcsCredentialsUnmanaged;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    get(body?: AcsCredentialsUnmanagedGetParams): SeamHttpRequest<AcsCredentialsUnmanagedGetResponse, 'acs_credential'>;
    list(body?: AcsCredentialsUnmanagedListParams): SeamHttpRequest<AcsCredentialsUnmanagedListResponse, 'acs_credentials'>;
}
type AcsCredentialsUnmanagedGetParams = RouteRequestBody<'/acs/credentials/unmanaged/get'>;
type AcsCredentialsUnmanagedGetResponse = SetNonNullable<Required<RouteResponse<'/acs/credentials/unmanaged/get'>>>;
type AcsCredentialsUnmanagedGetOptions = never;
type AcsCredentialsUnmanagedListParams = RouteRequestBody<'/acs/credentials/unmanaged/list'>;
type AcsCredentialsUnmanagedListResponse = SetNonNullable<Required<RouteResponse<'/acs/credentials/unmanaged/list'>>>;
type AcsCredentialsUnmanagedListOptions = never;

declare class SeamHttpAcsCredentials {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpAcsCredentials;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpAcsCredentials;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpAcsCredentials;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpAcsCredentials>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpAcsCredentials;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpAcsCredentials;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    get unmanaged(): SeamHttpAcsCredentialsUnmanaged;
    assign(body?: AcsCredentialsAssignBody): SeamHttpRequest<void, undefined>;
    create(body?: AcsCredentialsCreateBody): SeamHttpRequest<AcsCredentialsCreateResponse, 'acs_credential'>;
    delete(body?: AcsCredentialsDeleteParams): SeamHttpRequest<void, undefined>;
    get(body?: AcsCredentialsGetParams): SeamHttpRequest<AcsCredentialsGetResponse, 'acs_credential'>;
    list(body?: AcsCredentialsListParams): SeamHttpRequest<AcsCredentialsListResponse, 'acs_credentials'>;
    listAccessibleEntrances(body?: AcsCredentialsListAccessibleEntrancesParams): SeamHttpRequest<AcsCredentialsListAccessibleEntrancesResponse, 'acs_entrances'>;
    unassign(body?: AcsCredentialsUnassignBody): SeamHttpRequest<void, undefined>;
    update(body?: AcsCredentialsUpdateBody): SeamHttpRequest<void, undefined>;
}
type AcsCredentialsAssignBody = RouteRequestBody<'/acs/credentials/assign'>;
type AcsCredentialsAssignResponse = SetNonNullable<Required<RouteResponse<'/acs/credentials/assign'>>>;
type AcsCredentialsAssignOptions = never;
type AcsCredentialsCreateBody = RouteRequestBody<'/acs/credentials/create'>;
type AcsCredentialsCreateResponse = SetNonNullable<Required<RouteResponse<'/acs/credentials/create'>>>;
type AcsCredentialsCreateOptions = never;
type AcsCredentialsDeleteParams = RouteRequestBody<'/acs/credentials/delete'>;
type AcsCredentialsDeleteResponse = SetNonNullable<Required<RouteResponse<'/acs/credentials/delete'>>>;
type AcsCredentialsDeleteOptions = never;
type AcsCredentialsGetParams = RouteRequestBody<'/acs/credentials/get'>;
type AcsCredentialsGetResponse = SetNonNullable<Required<RouteResponse<'/acs/credentials/get'>>>;
type AcsCredentialsGetOptions = never;
type AcsCredentialsListParams = RouteRequestBody<'/acs/credentials/list'>;
type AcsCredentialsListResponse = SetNonNullable<Required<RouteResponse<'/acs/credentials/list'>>>;
type AcsCredentialsListOptions = never;
type AcsCredentialsListAccessibleEntrancesParams = RouteRequestBody<'/acs/credentials/list_accessible_entrances'>;
type AcsCredentialsListAccessibleEntrancesResponse = SetNonNullable<Required<RouteResponse<'/acs/credentials/list_accessible_entrances'>>>;
type AcsCredentialsListAccessibleEntrancesOptions = never;
type AcsCredentialsUnassignBody = RouteRequestBody<'/acs/credentials/unassign'>;
type AcsCredentialsUnassignResponse = SetNonNullable<Required<RouteResponse<'/acs/credentials/unassign'>>>;
type AcsCredentialsUnassignOptions = never;
type AcsCredentialsUpdateBody = RouteRequestBody<'/acs/credentials/update'>;
type AcsCredentialsUpdateResponse = SetNonNullable<Required<RouteResponse<'/acs/credentials/update'>>>;
type AcsCredentialsUpdateOptions = never;

declare class SeamHttpAcsEntrances {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpAcsEntrances;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpAcsEntrances;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpAcsEntrances;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpAcsEntrances>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpAcsEntrances;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpAcsEntrances;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    get(body?: AcsEntrancesGetParams): SeamHttpRequest<AcsEntrancesGetResponse, 'acs_entrance'>;
    grantAccess(body?: AcsEntrancesGrantAccessBody): SeamHttpRequest<void, undefined>;
    list(body?: AcsEntrancesListParams): SeamHttpRequest<AcsEntrancesListResponse, 'acs_entrances'>;
    listCredentialsWithAccess(body?: AcsEntrancesListCredentialsWithAccessParams): SeamHttpRequest<AcsEntrancesListCredentialsWithAccessResponse, 'acs_credentials'>;
}
type AcsEntrancesGetParams = RouteRequestBody<'/acs/entrances/get'>;
type AcsEntrancesGetResponse = SetNonNullable<Required<RouteResponse<'/acs/entrances/get'>>>;
type AcsEntrancesGetOptions = never;
type AcsEntrancesGrantAccessBody = RouteRequestBody<'/acs/entrances/grant_access'>;
type AcsEntrancesGrantAccessResponse = SetNonNullable<Required<RouteResponse<'/acs/entrances/grant_access'>>>;
type AcsEntrancesGrantAccessOptions = never;
type AcsEntrancesListParams = RouteRequestBody<'/acs/entrances/list'>;
type AcsEntrancesListResponse = SetNonNullable<Required<RouteResponse<'/acs/entrances/list'>>>;
type AcsEntrancesListOptions = never;
type AcsEntrancesListCredentialsWithAccessParams = RouteRequestBody<'/acs/entrances/list_credentials_with_access'>;
type AcsEntrancesListCredentialsWithAccessResponse = SetNonNullable<Required<RouteResponse<'/acs/entrances/list_credentials_with_access'>>>;
type AcsEntrancesListCredentialsWithAccessOptions = never;

declare class SeamHttpAcsSystems {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpAcsSystems;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpAcsSystems;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpAcsSystems;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpAcsSystems>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpAcsSystems;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpAcsSystems;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    get(body?: AcsSystemsGetParams): SeamHttpRequest<AcsSystemsGetResponse, 'acs_system'>;
    list(body?: AcsSystemsListParams): SeamHttpRequest<AcsSystemsListResponse, 'acs_systems'>;
    listCompatibleCredentialManagerAcsSystems(body?: AcsSystemsListCompatibleCredentialManagerAcsSystemsParams): SeamHttpRequest<AcsSystemsListCompatibleCredentialManagerAcsSystemsResponse, 'acs_systems'>;
}
type AcsSystemsGetParams = RouteRequestBody<'/acs/systems/get'>;
type AcsSystemsGetResponse = SetNonNullable<Required<RouteResponse<'/acs/systems/get'>>>;
type AcsSystemsGetOptions = never;
type AcsSystemsListParams = RouteRequestBody<'/acs/systems/list'>;
type AcsSystemsListResponse = SetNonNullable<Required<RouteResponse<'/acs/systems/list'>>>;
type AcsSystemsListOptions = never;
type AcsSystemsListCompatibleCredentialManagerAcsSystemsParams = RouteRequestBody<'/acs/systems/list_compatible_credential_manager_acs_systems'>;
type AcsSystemsListCompatibleCredentialManagerAcsSystemsResponse = SetNonNullable<Required<RouteResponse<'/acs/systems/list_compatible_credential_manager_acs_systems'>>>;
type AcsSystemsListCompatibleCredentialManagerAcsSystemsOptions = never;

declare class SeamHttpAcsUsersUnmanaged {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpAcsUsersUnmanaged;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpAcsUsersUnmanaged;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpAcsUsersUnmanaged;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpAcsUsersUnmanaged>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpAcsUsersUnmanaged;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpAcsUsersUnmanaged;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    get(body?: AcsUsersUnmanagedGetParams): SeamHttpRequest<AcsUsersUnmanagedGetResponse, 'acs_user'>;
    list(body?: AcsUsersUnmanagedListParams): SeamHttpRequest<AcsUsersUnmanagedListResponse, 'acs_users'>;
}
type AcsUsersUnmanagedGetParams = RouteRequestBody<'/acs/users/unmanaged/get'>;
type AcsUsersUnmanagedGetResponse = SetNonNullable<Required<RouteResponse<'/acs/users/unmanaged/get'>>>;
type AcsUsersUnmanagedGetOptions = never;
type AcsUsersUnmanagedListParams = RouteRequestBody<'/acs/users/unmanaged/list'>;
type AcsUsersUnmanagedListResponse = SetNonNullable<Required<RouteResponse<'/acs/users/unmanaged/list'>>>;
type AcsUsersUnmanagedListOptions = never;

declare class SeamHttpAcsUsers {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpAcsUsers;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpAcsUsers;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpAcsUsers;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpAcsUsers>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpAcsUsers;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpAcsUsers;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    get unmanaged(): SeamHttpAcsUsersUnmanaged;
    addToAccessGroup(body?: AcsUsersAddToAccessGroupBody): SeamHttpRequest<void, undefined>;
    create(body?: AcsUsersCreateBody): SeamHttpRequest<AcsUsersCreateResponse, 'acs_user'>;
    delete(body?: AcsUsersDeleteParams): SeamHttpRequest<void, undefined>;
    get(body?: AcsUsersGetParams): SeamHttpRequest<AcsUsersGetResponse, 'acs_user'>;
    list(body?: AcsUsersListParams): SeamHttpRequest<AcsUsersListResponse, 'acs_users'>;
    listAccessibleEntrances(body?: AcsUsersListAccessibleEntrancesParams): SeamHttpRequest<AcsUsersListAccessibleEntrancesResponse, 'acs_entrances'>;
    removeFromAccessGroup(body?: AcsUsersRemoveFromAccessGroupParams): SeamHttpRequest<void, undefined>;
    revokeAccessToAllEntrances(body?: AcsUsersRevokeAccessToAllEntrancesParams): SeamHttpRequest<void, undefined>;
    suspend(body?: AcsUsersSuspendBody): SeamHttpRequest<void, undefined>;
    unsuspend(body?: AcsUsersUnsuspendBody): SeamHttpRequest<void, undefined>;
    update(body?: AcsUsersUpdateBody): SeamHttpRequest<void, undefined>;
}
type AcsUsersAddToAccessGroupBody = RouteRequestBody<'/acs/users/add_to_access_group'>;
type AcsUsersAddToAccessGroupResponse = SetNonNullable<Required<RouteResponse<'/acs/users/add_to_access_group'>>>;
type AcsUsersAddToAccessGroupOptions = never;
type AcsUsersCreateBody = RouteRequestBody<'/acs/users/create'>;
type AcsUsersCreateResponse = SetNonNullable<Required<RouteResponse<'/acs/users/create'>>>;
type AcsUsersCreateOptions = never;
type AcsUsersDeleteParams = RouteRequestBody<'/acs/users/delete'>;
type AcsUsersDeleteResponse = SetNonNullable<Required<RouteResponse<'/acs/users/delete'>>>;
type AcsUsersDeleteOptions = never;
type AcsUsersGetParams = RouteRequestBody<'/acs/users/get'>;
type AcsUsersGetResponse = SetNonNullable<Required<RouteResponse<'/acs/users/get'>>>;
type AcsUsersGetOptions = never;
type AcsUsersListParams = RouteRequestBody<'/acs/users/list'>;
type AcsUsersListResponse = SetNonNullable<Required<RouteResponse<'/acs/users/list'>>>;
type AcsUsersListOptions = never;
type AcsUsersListAccessibleEntrancesParams = RouteRequestBody<'/acs/users/list_accessible_entrances'>;
type AcsUsersListAccessibleEntrancesResponse = SetNonNullable<Required<RouteResponse<'/acs/users/list_accessible_entrances'>>>;
type AcsUsersListAccessibleEntrancesOptions = never;
type AcsUsersRemoveFromAccessGroupParams = RouteRequestBody<'/acs/users/remove_from_access_group'>;
type AcsUsersRemoveFromAccessGroupResponse = SetNonNullable<Required<RouteResponse<'/acs/users/remove_from_access_group'>>>;
type AcsUsersRemoveFromAccessGroupOptions = never;
type AcsUsersRevokeAccessToAllEntrancesParams = RouteRequestBody<'/acs/users/revoke_access_to_all_entrances'>;
type AcsUsersRevokeAccessToAllEntrancesResponse = SetNonNullable<Required<RouteResponse<'/acs/users/revoke_access_to_all_entrances'>>>;
type AcsUsersRevokeAccessToAllEntrancesOptions = never;
type AcsUsersSuspendBody = RouteRequestBody<'/acs/users/suspend'>;
type AcsUsersSuspendResponse = SetNonNullable<Required<RouteResponse<'/acs/users/suspend'>>>;
type AcsUsersSuspendOptions = never;
type AcsUsersUnsuspendBody = RouteRequestBody<'/acs/users/unsuspend'>;
type AcsUsersUnsuspendResponse = SetNonNullable<Required<RouteResponse<'/acs/users/unsuspend'>>>;
type AcsUsersUnsuspendOptions = never;
type AcsUsersUpdateBody = RouteRequestBody<'/acs/users/update'>;
type AcsUsersUpdateResponse = SetNonNullable<Required<RouteResponse<'/acs/users/update'>>>;
type AcsUsersUpdateOptions = never;

declare class SeamHttpAcs {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpAcs;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpAcs;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpAcs;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpAcs>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpAcs;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpAcs;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    get accessGroups(): SeamHttpAcsAccessGroups;
    get credentialPools(): SeamHttpAcsCredentialPools;
    get credentialProvisioningAutomations(): SeamHttpAcsCredentialProvisioningAutomations;
    get credentials(): SeamHttpAcsCredentials;
    get entrances(): SeamHttpAcsEntrances;
    get systems(): SeamHttpAcsSystems;
    get users(): SeamHttpAcsUsers;
}

declare class SeamHttpAcsEncoders {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpAcsEncoders;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpAcsEncoders;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpAcsEncoders;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpAcsEncoders>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpAcsEncoders;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpAcsEncoders;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    encodeCard(body?: AcsEncodersEncodeCardBody, options?: Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>): SeamHttpRequest<AcsEncodersEncodeCardResponse, 'action_attempt'>;
    list(body?: AcsEncodersListParams): SeamHttpRequest<AcsEncodersListResponse, 'devices'>;
    readCard(body?: AcsEncodersReadCardBody, options?: Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>): SeamHttpRequest<AcsEncodersReadCardResponse, 'action_attempt'>;
}
type AcsEncodersEncodeCardBody = RouteRequestBody<'/acs/encoders/encode_card'>;
type AcsEncodersEncodeCardResponse = SetNonNullable<Required<RouteResponse<'/acs/encoders/encode_card'>>>;
type AcsEncodersEncodeCardOptions = Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>;
type AcsEncodersListParams = RouteRequestBody<'/acs/encoders/list'>;
type AcsEncodersListResponse = SetNonNullable<Required<RouteResponse<'/acs/encoders/list'>>>;
type AcsEncodersListOptions = never;
type AcsEncodersReadCardBody = RouteRequestBody<'/acs/encoders/read_card'>;
type AcsEncodersReadCardResponse = SetNonNullable<Required<RouteResponse<'/acs/encoders/read_card'>>>;
type AcsEncodersReadCardOptions = Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>;

declare class SeamHttpActionAttempts {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpActionAttempts;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpActionAttempts;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpActionAttempts;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpActionAttempts>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpActionAttempts;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpActionAttempts;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    get(body?: ActionAttemptsGetParams, options?: Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>): SeamHttpRequest<ActionAttemptsGetResponse, 'action_attempt'>;
    list(body?: ActionAttemptsListParams): SeamHttpRequest<ActionAttemptsListResponse, 'action_attempts'>;
}
type ActionAttemptsGetParams = RouteRequestBody<'/action_attempts/get'>;
type ActionAttemptsGetResponse = SetNonNullable<Required<RouteResponse<'/action_attempts/get'>>>;
type ActionAttemptsGetOptions = Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>;
type ActionAttemptsListParams = RouteRequestBody<'/action_attempts/list'>;
type ActionAttemptsListResponse = SetNonNullable<Required<RouteResponse<'/action_attempts/list'>>>;
type ActionAttemptsListOptions = never;

declare class SeamHttpClientSessions {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpClientSessions;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpClientSessions;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpClientSessions;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpClientSessions>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpClientSessions;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpClientSessions;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    create(body?: ClientSessionsCreateBody): SeamHttpRequest<ClientSessionsCreateResponse, 'client_session'>;
    delete(body?: ClientSessionsDeleteParams): SeamHttpRequest<void, undefined>;
    get(body?: ClientSessionsGetParams): SeamHttpRequest<ClientSessionsGetResponse, 'client_session'>;
    getOrCreate(body?: ClientSessionsGetOrCreateBody): SeamHttpRequest<ClientSessionsGetOrCreateResponse, 'client_session'>;
    grantAccess(body?: ClientSessionsGrantAccessBody): SeamHttpRequest<void, undefined>;
    list(body?: ClientSessionsListParams): SeamHttpRequest<ClientSessionsListResponse, 'client_sessions'>;
    revoke(body?: ClientSessionsRevokeParams): SeamHttpRequest<void, undefined>;
}
type ClientSessionsCreateBody = RouteRequestBody<'/client_sessions/create'>;
type ClientSessionsCreateResponse = SetNonNullable<Required<RouteResponse<'/client_sessions/create'>>>;
type ClientSessionsCreateOptions = never;
type ClientSessionsDeleteParams = RouteRequestBody<'/client_sessions/delete'>;
type ClientSessionsDeleteResponse = SetNonNullable<Required<RouteResponse<'/client_sessions/delete'>>>;
type ClientSessionsDeleteOptions = never;
type ClientSessionsGetParams = RouteRequestBody<'/client_sessions/get'>;
type ClientSessionsGetResponse = SetNonNullable<Required<RouteResponse<'/client_sessions/get'>>>;
type ClientSessionsGetOptions = never;
type ClientSessionsGetOrCreateBody = RouteRequestBody<'/client_sessions/get_or_create'>;
type ClientSessionsGetOrCreateResponse = SetNonNullable<Required<RouteResponse<'/client_sessions/get_or_create'>>>;
type ClientSessionsGetOrCreateOptions = never;
type ClientSessionsGrantAccessBody = RouteRequestBody<'/client_sessions/grant_access'>;
type ClientSessionsGrantAccessResponse = SetNonNullable<Required<RouteResponse<'/client_sessions/grant_access'>>>;
type ClientSessionsGrantAccessOptions = never;
type ClientSessionsListParams = RouteRequestBody<'/client_sessions/list'>;
type ClientSessionsListResponse = SetNonNullable<Required<RouteResponse<'/client_sessions/list'>>>;
type ClientSessionsListOptions = never;
type ClientSessionsRevokeParams = RouteRequestBody<'/client_sessions/revoke'>;
type ClientSessionsRevokeResponse = SetNonNullable<Required<RouteResponse<'/client_sessions/revoke'>>>;
type ClientSessionsRevokeOptions = never;

declare class SeamHttpConnectWebviews {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpConnectWebviews;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpConnectWebviews;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpConnectWebviews;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpConnectWebviews>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpConnectWebviews;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpConnectWebviews;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    create(body?: ConnectWebviewsCreateBody): SeamHttpRequest<ConnectWebviewsCreateResponse, 'connect_webview'>;
    delete(body?: ConnectWebviewsDeleteParams): SeamHttpRequest<void, undefined>;
    get(body?: ConnectWebviewsGetParams): SeamHttpRequest<ConnectWebviewsGetResponse, 'connect_webview'>;
    list(body?: ConnectWebviewsListParams): SeamHttpRequest<ConnectWebviewsListResponse, 'connect_webviews'>;
}
type ConnectWebviewsCreateBody = RouteRequestBody<'/connect_webviews/create'>;
type ConnectWebviewsCreateResponse = SetNonNullable<Required<RouteResponse<'/connect_webviews/create'>>>;
type ConnectWebviewsCreateOptions = never;
type ConnectWebviewsDeleteParams = RouteRequestBody<'/connect_webviews/delete'>;
type ConnectWebviewsDeleteResponse = SetNonNullable<Required<RouteResponse<'/connect_webviews/delete'>>>;
type ConnectWebviewsDeleteOptions = never;
type ConnectWebviewsGetParams = RouteRequestBody<'/connect_webviews/get'>;
type ConnectWebviewsGetResponse = SetNonNullable<Required<RouteResponse<'/connect_webviews/get'>>>;
type ConnectWebviewsGetOptions = never;
type ConnectWebviewsListParams = RouteRequestBody<'/connect_webviews/list'>;
type ConnectWebviewsListResponse = SetNonNullable<Required<RouteResponse<'/connect_webviews/list'>>>;
type ConnectWebviewsListOptions = never;

declare class SeamHttpConnectedAccounts {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpConnectedAccounts;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpConnectedAccounts;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpConnectedAccounts;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpConnectedAccounts>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpConnectedAccounts;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpConnectedAccounts;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    delete(body?: ConnectedAccountsDeleteParams): SeamHttpRequest<void, undefined>;
    get(body?: ConnectedAccountsGetParams): SeamHttpRequest<ConnectedAccountsGetResponse, 'connected_account'>;
    list(body?: ConnectedAccountsListParams): SeamHttpRequest<ConnectedAccountsListResponse, 'connected_accounts'>;
    update(body?: ConnectedAccountsUpdateBody): SeamHttpRequest<ConnectedAccountsUpdateResponse, 'connected_account'>;
}
type ConnectedAccountsDeleteParams = RouteRequestBody<'/connected_accounts/delete'>;
type ConnectedAccountsDeleteResponse = SetNonNullable<Required<RouteResponse<'/connected_accounts/delete'>>>;
type ConnectedAccountsDeleteOptions = never;
type ConnectedAccountsGetParams = RouteRequestBody<'/connected_accounts/get'>;
type ConnectedAccountsGetResponse = SetNonNullable<Required<RouteResponse<'/connected_accounts/get'>>>;
type ConnectedAccountsGetOptions = never;
type ConnectedAccountsListParams = RouteRequestBody<'/connected_accounts/list'>;
type ConnectedAccountsListResponse = SetNonNullable<Required<RouteResponse<'/connected_accounts/list'>>>;
type ConnectedAccountsListOptions = never;
type ConnectedAccountsUpdateBody = RouteRequestBody<'/connected_accounts/update'>;
type ConnectedAccountsUpdateResponse = SetNonNullable<Required<RouteResponse<'/connected_accounts/update'>>>;
type ConnectedAccountsUpdateOptions = never;

declare class SeamHttpDevicesSimulate {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpDevicesSimulate;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpDevicesSimulate;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpDevicesSimulate;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpDevicesSimulate>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpDevicesSimulate;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpDevicesSimulate;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    connect(body?: DevicesSimulateConnectBody): SeamHttpRequest<void, undefined>;
    disconnect(body?: DevicesSimulateDisconnectBody): SeamHttpRequest<void, undefined>;
    remove(body?: DevicesSimulateRemoveParams): SeamHttpRequest<void, undefined>;
}
type DevicesSimulateConnectBody = RouteRequestBody<'/devices/simulate/connect'>;
type DevicesSimulateConnectResponse = SetNonNullable<Required<RouteResponse<'/devices/simulate/connect'>>>;
type DevicesSimulateConnectOptions = never;
type DevicesSimulateDisconnectBody = RouteRequestBody<'/devices/simulate/disconnect'>;
type DevicesSimulateDisconnectResponse = SetNonNullable<Required<RouteResponse<'/devices/simulate/disconnect'>>>;
type DevicesSimulateDisconnectOptions = never;
type DevicesSimulateRemoveParams = RouteRequestBody<'/devices/simulate/remove'>;
type DevicesSimulateRemoveResponse = SetNonNullable<Required<RouteResponse<'/devices/simulate/remove'>>>;
type DevicesSimulateRemoveOptions = never;

declare class SeamHttpDevicesUnmanaged {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpDevicesUnmanaged;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpDevicesUnmanaged;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpDevicesUnmanaged;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpDevicesUnmanaged>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpDevicesUnmanaged;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpDevicesUnmanaged;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    get(body?: DevicesUnmanagedGetParams): SeamHttpRequest<DevicesUnmanagedGetResponse, 'device'>;
    list(body?: DevicesUnmanagedListParams): SeamHttpRequest<DevicesUnmanagedListResponse, 'devices'>;
    update(body?: DevicesUnmanagedUpdateBody): SeamHttpRequest<void, undefined>;
}
type DevicesUnmanagedGetParams = RouteRequestBody<'/devices/unmanaged/get'>;
type DevicesUnmanagedGetResponse = SetNonNullable<Required<RouteResponse<'/devices/unmanaged/get'>>>;
type DevicesUnmanagedGetOptions = never;
type DevicesUnmanagedListParams = RouteRequestBody<'/devices/unmanaged/list'>;
type DevicesUnmanagedListResponse = SetNonNullable<Required<RouteResponse<'/devices/unmanaged/list'>>>;
type DevicesUnmanagedListOptions = never;
type DevicesUnmanagedUpdateBody = RouteRequestBody<'/devices/unmanaged/update'>;
type DevicesUnmanagedUpdateResponse = SetNonNullable<Required<RouteResponse<'/devices/unmanaged/update'>>>;
type DevicesUnmanagedUpdateOptions = never;

declare class SeamHttpDevices {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpDevices;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpDevices;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpDevices;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpDevices>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpDevices;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpDevices;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    get unmanaged(): SeamHttpDevicesUnmanaged;
    get simulate(): SeamHttpDevicesSimulate;
    delete(body?: DevicesDeleteParams): SeamHttpRequest<void, undefined>;
    get(body?: DevicesGetParams): SeamHttpRequest<DevicesGetResponse, 'device'>;
    list(body?: DevicesListParams): SeamHttpRequest<DevicesListResponse, 'devices'>;
    listDeviceProviders(body?: DevicesListDeviceProvidersParams): SeamHttpRequest<DevicesListDeviceProvidersResponse, 'device_providers'>;
    update(body?: DevicesUpdateBody): SeamHttpRequest<void, undefined>;
}
type DevicesDeleteParams = RouteRequestBody<'/devices/delete'>;
type DevicesDeleteResponse = SetNonNullable<Required<RouteResponse<'/devices/delete'>>>;
type DevicesDeleteOptions = never;
type DevicesGetParams = RouteRequestBody<'/devices/get'>;
type DevicesGetResponse = SetNonNullable<Required<RouteResponse<'/devices/get'>>>;
type DevicesGetOptions = never;
type DevicesListParams = RouteRequestBody<'/devices/list'>;
type DevicesListResponse = SetNonNullable<Required<RouteResponse<'/devices/list'>>>;
type DevicesListOptions = never;
type DevicesListDeviceProvidersParams = RouteRequestBody<'/devices/list_device_providers'>;
type DevicesListDeviceProvidersResponse = SetNonNullable<Required<RouteResponse<'/devices/list_device_providers'>>>;
type DevicesListDeviceProvidersOptions = never;
type DevicesUpdateBody = RouteRequestBody<'/devices/update'>;
type DevicesUpdateResponse = SetNonNullable<Required<RouteResponse<'/devices/update'>>>;
type DevicesUpdateOptions = never;

declare class SeamHttpEvents {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpEvents;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpEvents;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpEvents;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpEvents>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpEvents;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpEvents;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    get(body?: EventsGetParams): SeamHttpRequest<EventsGetResponse, 'event'>;
    list(body?: EventsListParams): SeamHttpRequest<EventsListResponse, 'events'>;
}
type EventsGetParams = RouteRequestBody<'/events/get'>;
type EventsGetResponse = SetNonNullable<Required<RouteResponse<'/events/get'>>>;
type EventsGetOptions = never;
type EventsListParams = RouteRequestBody<'/events/list'>;
type EventsListResponse = SetNonNullable<Required<RouteResponse<'/events/list'>>>;
type EventsListOptions = never;

declare class SeamHttpLocks {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpLocks;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpLocks;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpLocks;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpLocks>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpLocks;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpLocks;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    get(body?: LocksGetParams): SeamHttpRequest<LocksGetResponse, 'device'>;
    list(body?: LocksListParams): SeamHttpRequest<LocksListResponse, 'devices'>;
    lockDoor(body?: LocksLockDoorBody, options?: Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>): SeamHttpRequest<LocksLockDoorResponse, 'action_attempt'>;
    unlockDoor(body?: LocksUnlockDoorBody, options?: Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>): SeamHttpRequest<LocksUnlockDoorResponse, 'action_attempt'>;
}
type LocksGetParams = RouteRequestBody<'/locks/get'>;
type LocksGetResponse = SetNonNullable<Required<RouteResponse<'/locks/get'>>>;
type LocksGetOptions = never;
type LocksListParams = RouteRequestBody<'/locks/list'>;
type LocksListResponse = SetNonNullable<Required<RouteResponse<'/locks/list'>>>;
type LocksListOptions = never;
type LocksLockDoorBody = RouteRequestBody<'/locks/lock_door'>;
type LocksLockDoorResponse = SetNonNullable<Required<RouteResponse<'/locks/lock_door'>>>;
type LocksLockDoorOptions = Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>;
type LocksUnlockDoorBody = RouteRequestBody<'/locks/unlock_door'>;
type LocksUnlockDoorResponse = SetNonNullable<Required<RouteResponse<'/locks/unlock_door'>>>;
type LocksUnlockDoorOptions = Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>;

declare class SeamHttpNetworks {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpNetworks;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpNetworks;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpNetworks;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpNetworks>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpNetworks;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpNetworks;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    get(body?: NetworksGetParams): SeamHttpRequest<NetworksGetResponse, 'network'>;
    list(body?: NetworksListParams): SeamHttpRequest<NetworksListResponse, 'networks'>;
}
type NetworksGetParams = RouteRequestBody<'/networks/get'>;
type NetworksGetResponse = SetNonNullable<Required<RouteResponse<'/networks/get'>>>;
type NetworksGetOptions = never;
type NetworksListParams = RouteRequestBody<'/networks/list'>;
type NetworksListResponse = SetNonNullable<Required<RouteResponse<'/networks/list'>>>;
type NetworksListOptions = never;

declare class SeamHttpNoiseSensorsNoiseThresholds {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpNoiseSensorsNoiseThresholds;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpNoiseSensorsNoiseThresholds;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpNoiseSensorsNoiseThresholds;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpNoiseSensorsNoiseThresholds>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpNoiseSensorsNoiseThresholds;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpNoiseSensorsNoiseThresholds;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    create(body?: NoiseSensorsNoiseThresholdsCreateBody): SeamHttpRequest<NoiseSensorsNoiseThresholdsCreateResponse, 'noise_threshold'>;
    delete(body?: NoiseSensorsNoiseThresholdsDeleteParams): SeamHttpRequest<void, undefined>;
    get(body?: NoiseSensorsNoiseThresholdsGetParams): SeamHttpRequest<NoiseSensorsNoiseThresholdsGetResponse, 'noise_threshold'>;
    list(body?: NoiseSensorsNoiseThresholdsListParams): SeamHttpRequest<NoiseSensorsNoiseThresholdsListResponse, 'noise_thresholds'>;
    update(body?: NoiseSensorsNoiseThresholdsUpdateBody): SeamHttpRequest<void, undefined>;
}
type NoiseSensorsNoiseThresholdsCreateBody = RouteRequestBody<'/noise_sensors/noise_thresholds/create'>;
type NoiseSensorsNoiseThresholdsCreateResponse = SetNonNullable<Required<RouteResponse<'/noise_sensors/noise_thresholds/create'>>>;
type NoiseSensorsNoiseThresholdsCreateOptions = never;
type NoiseSensorsNoiseThresholdsDeleteParams = RouteRequestBody<'/noise_sensors/noise_thresholds/delete'>;
type NoiseSensorsNoiseThresholdsDeleteResponse = SetNonNullable<Required<RouteResponse<'/noise_sensors/noise_thresholds/delete'>>>;
type NoiseSensorsNoiseThresholdsDeleteOptions = never;
type NoiseSensorsNoiseThresholdsGetParams = RouteRequestBody<'/noise_sensors/noise_thresholds/get'>;
type NoiseSensorsNoiseThresholdsGetResponse = SetNonNullable<Required<RouteResponse<'/noise_sensors/noise_thresholds/get'>>>;
type NoiseSensorsNoiseThresholdsGetOptions = never;
type NoiseSensorsNoiseThresholdsListParams = RouteRequestBody<'/noise_sensors/noise_thresholds/list'>;
type NoiseSensorsNoiseThresholdsListResponse = SetNonNullable<Required<RouteResponse<'/noise_sensors/noise_thresholds/list'>>>;
type NoiseSensorsNoiseThresholdsListOptions = never;
type NoiseSensorsNoiseThresholdsUpdateBody = RouteRequestBody<'/noise_sensors/noise_thresholds/update'>;
type NoiseSensorsNoiseThresholdsUpdateResponse = SetNonNullable<Required<RouteResponse<'/noise_sensors/noise_thresholds/update'>>>;
type NoiseSensorsNoiseThresholdsUpdateOptions = never;

declare class SeamHttpNoiseSensorsSimulate {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpNoiseSensorsSimulate;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpNoiseSensorsSimulate;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpNoiseSensorsSimulate;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpNoiseSensorsSimulate>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpNoiseSensorsSimulate;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpNoiseSensorsSimulate;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    triggerNoiseThreshold(body?: NoiseSensorsSimulateTriggerNoiseThresholdBody): SeamHttpRequest<void, undefined>;
}
type NoiseSensorsSimulateTriggerNoiseThresholdBody = RouteRequestBody<'/noise_sensors/simulate/trigger_noise_threshold'>;
type NoiseSensorsSimulateTriggerNoiseThresholdResponse = SetNonNullable<Required<RouteResponse<'/noise_sensors/simulate/trigger_noise_threshold'>>>;
type NoiseSensorsSimulateTriggerNoiseThresholdOptions = never;

declare class SeamHttpNoiseSensors {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpNoiseSensors;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpNoiseSensors;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpNoiseSensors;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpNoiseSensors>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpNoiseSensors;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpNoiseSensors;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    get noiseThresholds(): SeamHttpNoiseSensorsNoiseThresholds;
    get simulate(): SeamHttpNoiseSensorsSimulate;
    list(body?: NoiseSensorsListParams): SeamHttpRequest<NoiseSensorsListResponse, 'devices'>;
}
type NoiseSensorsListParams = RouteRequestBody<'/noise_sensors/list'>;
type NoiseSensorsListResponse = SetNonNullable<Required<RouteResponse<'/noise_sensors/list'>>>;
type NoiseSensorsListOptions = never;

declare class SeamHttpPhonesSimulate {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpPhonesSimulate;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpPhonesSimulate;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpPhonesSimulate;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpPhonesSimulate>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpPhonesSimulate;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpPhonesSimulate;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    createSandboxPhone(body?: PhonesSimulateCreateSandboxPhoneBody): SeamHttpRequest<PhonesSimulateCreateSandboxPhoneResponse, 'phone'>;
}
type PhonesSimulateCreateSandboxPhoneBody = RouteRequestBody<'/phones/simulate/create_sandbox_phone'>;
type PhonesSimulateCreateSandboxPhoneResponse = SetNonNullable<Required<RouteResponse<'/phones/simulate/create_sandbox_phone'>>>;
type PhonesSimulateCreateSandboxPhoneOptions = never;

declare class SeamHttpPhones {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpPhones;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpPhones;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpPhones;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpPhones>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpPhones;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpPhones;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    get simulate(): SeamHttpPhonesSimulate;
    deactivate(body?: PhonesDeactivateParams): SeamHttpRequest<void, undefined>;
    list(body?: PhonesListParams): SeamHttpRequest<PhonesListResponse, 'phones'>;
}
type PhonesDeactivateParams = RouteRequestBody<'/phones/deactivate'>;
type PhonesDeactivateResponse = SetNonNullable<Required<RouteResponse<'/phones/deactivate'>>>;
type PhonesDeactivateOptions = never;
type PhonesListParams = RouteRequestBody<'/phones/list'>;
type PhonesListResponse = SetNonNullable<Required<RouteResponse<'/phones/list'>>>;
type PhonesListOptions = never;

declare class SeamHttpThermostatsSchedules {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpThermostatsSchedules;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpThermostatsSchedules;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpThermostatsSchedules;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpThermostatsSchedules>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpThermostatsSchedules;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpThermostatsSchedules;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    create(body?: ThermostatsSchedulesCreateBody): SeamHttpRequest<ThermostatsSchedulesCreateResponse, 'thermostat_schedule'>;
    delete(body?: ThermostatsSchedulesDeleteParams): SeamHttpRequest<void, undefined>;
    get(body?: ThermostatsSchedulesGetParams): SeamHttpRequest<ThermostatsSchedulesGetResponse, 'thermostat_schedule'>;
    list(body?: ThermostatsSchedulesListParams): SeamHttpRequest<ThermostatsSchedulesListResponse, 'thermostat_schedules'>;
    update(body?: ThermostatsSchedulesUpdateBody): SeamHttpRequest<void, undefined>;
}
type ThermostatsSchedulesCreateBody = RouteRequestBody<'/thermostats/schedules/create'>;
type ThermostatsSchedulesCreateResponse = SetNonNullable<Required<RouteResponse<'/thermostats/schedules/create'>>>;
type ThermostatsSchedulesCreateOptions = never;
type ThermostatsSchedulesDeleteParams = RouteRequestBody<'/thermostats/schedules/delete'>;
type ThermostatsSchedulesDeleteResponse = SetNonNullable<Required<RouteResponse<'/thermostats/schedules/delete'>>>;
type ThermostatsSchedulesDeleteOptions = never;
type ThermostatsSchedulesGetParams = RouteRequestBody<'/thermostats/schedules/get'>;
type ThermostatsSchedulesGetResponse = SetNonNullable<Required<RouteResponse<'/thermostats/schedules/get'>>>;
type ThermostatsSchedulesGetOptions = never;
type ThermostatsSchedulesListParams = RouteRequestBody<'/thermostats/schedules/list'>;
type ThermostatsSchedulesListResponse = SetNonNullable<Required<RouteResponse<'/thermostats/schedules/list'>>>;
type ThermostatsSchedulesListOptions = never;
type ThermostatsSchedulesUpdateBody = RouteRequestBody<'/thermostats/schedules/update'>;
type ThermostatsSchedulesUpdateResponse = SetNonNullable<Required<RouteResponse<'/thermostats/schedules/update'>>>;
type ThermostatsSchedulesUpdateOptions = never;

declare class SeamHttpThermostats {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpThermostats;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpThermostats;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpThermostats;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpThermostats>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpThermostats;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpThermostats;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    get schedules(): SeamHttpThermostatsSchedules;
    activateClimatePreset(body?: ThermostatsActivateClimatePresetBody, options?: Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>): SeamHttpRequest<ThermostatsActivateClimatePresetResponse, 'action_attempt'>;
    cool(body?: ThermostatsCoolBody, options?: Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>): SeamHttpRequest<ThermostatsCoolResponse, 'action_attempt'>;
    createClimatePreset(body?: ThermostatsCreateClimatePresetBody): SeamHttpRequest<void, undefined>;
    deleteClimatePreset(body?: ThermostatsDeleteClimatePresetBody): SeamHttpRequest<void, undefined>;
    get(body?: ThermostatsGetParams): SeamHttpRequest<ThermostatsGetResponse, 'thermostat'>;
    heat(body?: ThermostatsHeatBody, options?: Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>): SeamHttpRequest<ThermostatsHeatResponse, 'action_attempt'>;
    heatCool(body?: ThermostatsHeatCoolBody, options?: Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>): SeamHttpRequest<ThermostatsHeatCoolResponse, 'action_attempt'>;
    list(body?: ThermostatsListParams): SeamHttpRequest<ThermostatsListResponse, 'thermostats'>;
    off(body?: ThermostatsOffBody, options?: Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>): SeamHttpRequest<ThermostatsOffResponse, 'action_attempt'>;
    setFallbackClimatePreset(body?: ThermostatsSetFallbackClimatePresetBody): SeamHttpRequest<void, undefined>;
    setFanMode(body?: ThermostatsSetFanModeBody, options?: Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>): SeamHttpRequest<ThermostatsSetFanModeResponse, 'action_attempt'>;
    updateClimatePreset(body?: ThermostatsUpdateClimatePresetBody): SeamHttpRequest<void, undefined>;
}
type ThermostatsActivateClimatePresetBody = RouteRequestBody<'/thermostats/activate_climate_preset'>;
type ThermostatsActivateClimatePresetResponse = SetNonNullable<Required<RouteResponse<'/thermostats/activate_climate_preset'>>>;
type ThermostatsActivateClimatePresetOptions = Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>;
type ThermostatsCoolBody = RouteRequestBody<'/thermostats/cool'>;
type ThermostatsCoolResponse = SetNonNullable<Required<RouteResponse<'/thermostats/cool'>>>;
type ThermostatsCoolOptions = Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>;
type ThermostatsCreateClimatePresetBody = RouteRequestBody<'/thermostats/create_climate_preset'>;
type ThermostatsCreateClimatePresetResponse = SetNonNullable<Required<RouteResponse<'/thermostats/create_climate_preset'>>>;
type ThermostatsCreateClimatePresetOptions = never;
type ThermostatsDeleteClimatePresetBody = RouteRequestBody<'/thermostats/delete_climate_preset'>;
type ThermostatsDeleteClimatePresetResponse = SetNonNullable<Required<RouteResponse<'/thermostats/delete_climate_preset'>>>;
type ThermostatsDeleteClimatePresetOptions = never;
type ThermostatsGetParams = RouteRequestBody<'/thermostats/get'>;
type ThermostatsGetResponse = SetNonNullable<Required<RouteResponse<'/thermostats/get'>>>;
type ThermostatsGetOptions = never;
type ThermostatsHeatBody = RouteRequestBody<'/thermostats/heat'>;
type ThermostatsHeatResponse = SetNonNullable<Required<RouteResponse<'/thermostats/heat'>>>;
type ThermostatsHeatOptions = Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>;
type ThermostatsHeatCoolBody = RouteRequestBody<'/thermostats/heat_cool'>;
type ThermostatsHeatCoolResponse = SetNonNullable<Required<RouteResponse<'/thermostats/heat_cool'>>>;
type ThermostatsHeatCoolOptions = Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>;
type ThermostatsListParams = RouteRequestBody<'/thermostats/list'>;
type ThermostatsListResponse = SetNonNullable<Required<RouteResponse<'/thermostats/list'>>>;
type ThermostatsListOptions = never;
type ThermostatsOffBody = RouteRequestBody<'/thermostats/off'>;
type ThermostatsOffResponse = SetNonNullable<Required<RouteResponse<'/thermostats/off'>>>;
type ThermostatsOffOptions = Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>;
type ThermostatsSetFallbackClimatePresetBody = RouteRequestBody<'/thermostats/set_fallback_climate_preset'>;
type ThermostatsSetFallbackClimatePresetResponse = SetNonNullable<Required<RouteResponse<'/thermostats/set_fallback_climate_preset'>>>;
type ThermostatsSetFallbackClimatePresetOptions = never;
type ThermostatsSetFanModeBody = RouteRequestBody<'/thermostats/set_fan_mode'>;
type ThermostatsSetFanModeResponse = SetNonNullable<Required<RouteResponse<'/thermostats/set_fan_mode'>>>;
type ThermostatsSetFanModeOptions = Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>;
type ThermostatsUpdateClimatePresetBody = RouteRequestBody<'/thermostats/update_climate_preset'>;
type ThermostatsUpdateClimatePresetResponse = SetNonNullable<Required<RouteResponse<'/thermostats/update_climate_preset'>>>;
type ThermostatsUpdateClimatePresetOptions = never;

declare class SeamHttpUserIdentitiesEnrollmentAutomations {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpUserIdentitiesEnrollmentAutomations;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpUserIdentitiesEnrollmentAutomations;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpUserIdentitiesEnrollmentAutomations;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpUserIdentitiesEnrollmentAutomations>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpUserIdentitiesEnrollmentAutomations;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpUserIdentitiesEnrollmentAutomations;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    delete(body?: UserIdentitiesEnrollmentAutomationsDeleteParams): SeamHttpRequest<void, undefined>;
    get(body?: UserIdentitiesEnrollmentAutomationsGetParams): SeamHttpRequest<UserIdentitiesEnrollmentAutomationsGetResponse, 'enrollment_automation'>;
    launch(body?: UserIdentitiesEnrollmentAutomationsLaunchBody): SeamHttpRequest<UserIdentitiesEnrollmentAutomationsLaunchResponse, 'enrollment_automation'>;
    list(body?: UserIdentitiesEnrollmentAutomationsListParams): SeamHttpRequest<UserIdentitiesEnrollmentAutomationsListResponse, 'enrollment_automations'>;
}
type UserIdentitiesEnrollmentAutomationsDeleteParams = RouteRequestBody<'/user_identities/enrollment_automations/delete'>;
type UserIdentitiesEnrollmentAutomationsDeleteResponse = SetNonNullable<Required<RouteResponse<'/user_identities/enrollment_automations/delete'>>>;
type UserIdentitiesEnrollmentAutomationsDeleteOptions = never;
type UserIdentitiesEnrollmentAutomationsGetParams = RouteRequestBody<'/user_identities/enrollment_automations/get'>;
type UserIdentitiesEnrollmentAutomationsGetResponse = SetNonNullable<Required<RouteResponse<'/user_identities/enrollment_automations/get'>>>;
type UserIdentitiesEnrollmentAutomationsGetOptions = never;
type UserIdentitiesEnrollmentAutomationsLaunchBody = RouteRequestBody<'/user_identities/enrollment_automations/launch'>;
type UserIdentitiesEnrollmentAutomationsLaunchResponse = SetNonNullable<Required<RouteResponse<'/user_identities/enrollment_automations/launch'>>>;
type UserIdentitiesEnrollmentAutomationsLaunchOptions = never;
type UserIdentitiesEnrollmentAutomationsListParams = RouteRequestBody<'/user_identities/enrollment_automations/list'>;
type UserIdentitiesEnrollmentAutomationsListResponse = SetNonNullable<Required<RouteResponse<'/user_identities/enrollment_automations/list'>>>;
type UserIdentitiesEnrollmentAutomationsListOptions = never;

declare class SeamHttpUserIdentities {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpUserIdentities;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpUserIdentities;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpUserIdentities;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpUserIdentities>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpUserIdentities;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpUserIdentities;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    get enrollmentAutomations(): SeamHttpUserIdentitiesEnrollmentAutomations;
    addAcsUser(body?: UserIdentitiesAddAcsUserBody): SeamHttpRequest<void, undefined>;
    create(body?: UserIdentitiesCreateBody): SeamHttpRequest<UserIdentitiesCreateResponse, 'user_identity'>;
    delete(body?: UserIdentitiesDeleteParams): SeamHttpRequest<void, undefined>;
    get(body?: UserIdentitiesGetParams): SeamHttpRequest<UserIdentitiesGetResponse, 'user_identity'>;
    grantAccessToDevice(body?: UserIdentitiesGrantAccessToDeviceBody): SeamHttpRequest<void, undefined>;
    list(body?: UserIdentitiesListParams): SeamHttpRequest<UserIdentitiesListResponse, 'user_identities'>;
    listAccessibleDevices(body?: UserIdentitiesListAccessibleDevicesParams): SeamHttpRequest<UserIdentitiesListAccessibleDevicesResponse, 'devices'>;
    listAcsSystems(body?: UserIdentitiesListAcsSystemsParams): SeamHttpRequest<UserIdentitiesListAcsSystemsResponse, 'acs_systems'>;
    listAcsUsers(body?: UserIdentitiesListAcsUsersParams): SeamHttpRequest<UserIdentitiesListAcsUsersResponse, 'acs_users'>;
    removeAcsUser(body?: UserIdentitiesRemoveAcsUserParams): SeamHttpRequest<void, undefined>;
    revokeAccessToDevice(body?: UserIdentitiesRevokeAccessToDeviceParams): SeamHttpRequest<void, undefined>;
    update(body?: UserIdentitiesUpdateBody): SeamHttpRequest<void, undefined>;
}
type UserIdentitiesAddAcsUserBody = RouteRequestBody<'/user_identities/add_acs_user'>;
type UserIdentitiesAddAcsUserResponse = SetNonNullable<Required<RouteResponse<'/user_identities/add_acs_user'>>>;
type UserIdentitiesAddAcsUserOptions = never;
type UserIdentitiesCreateBody = RouteRequestBody<'/user_identities/create'>;
type UserIdentitiesCreateResponse = SetNonNullable<Required<RouteResponse<'/user_identities/create'>>>;
type UserIdentitiesCreateOptions = never;
type UserIdentitiesDeleteParams = RouteRequestBody<'/user_identities/delete'>;
type UserIdentitiesDeleteResponse = SetNonNullable<Required<RouteResponse<'/user_identities/delete'>>>;
type UserIdentitiesDeleteOptions = never;
type UserIdentitiesGetParams = RouteRequestBody<'/user_identities/get'>;
type UserIdentitiesGetResponse = SetNonNullable<Required<RouteResponse<'/user_identities/get'>>>;
type UserIdentitiesGetOptions = never;
type UserIdentitiesGrantAccessToDeviceBody = RouteRequestBody<'/user_identities/grant_access_to_device'>;
type UserIdentitiesGrantAccessToDeviceResponse = SetNonNullable<Required<RouteResponse<'/user_identities/grant_access_to_device'>>>;
type UserIdentitiesGrantAccessToDeviceOptions = never;
type UserIdentitiesListParams = RouteRequestBody<'/user_identities/list'>;
type UserIdentitiesListResponse = SetNonNullable<Required<RouteResponse<'/user_identities/list'>>>;
type UserIdentitiesListOptions = never;
type UserIdentitiesListAccessibleDevicesParams = RouteRequestBody<'/user_identities/list_accessible_devices'>;
type UserIdentitiesListAccessibleDevicesResponse = SetNonNullable<Required<RouteResponse<'/user_identities/list_accessible_devices'>>>;
type UserIdentitiesListAccessibleDevicesOptions = never;
type UserIdentitiesListAcsSystemsParams = RouteRequestBody<'/user_identities/list_acs_systems'>;
type UserIdentitiesListAcsSystemsResponse = SetNonNullable<Required<RouteResponse<'/user_identities/list_acs_systems'>>>;
type UserIdentitiesListAcsSystemsOptions = never;
type UserIdentitiesListAcsUsersParams = RouteRequestBody<'/user_identities/list_acs_users'>;
type UserIdentitiesListAcsUsersResponse = SetNonNullable<Required<RouteResponse<'/user_identities/list_acs_users'>>>;
type UserIdentitiesListAcsUsersOptions = never;
type UserIdentitiesRemoveAcsUserParams = RouteRequestBody<'/user_identities/remove_acs_user'>;
type UserIdentitiesRemoveAcsUserResponse = SetNonNullable<Required<RouteResponse<'/user_identities/remove_acs_user'>>>;
type UserIdentitiesRemoveAcsUserOptions = never;
type UserIdentitiesRevokeAccessToDeviceParams = RouteRequestBody<'/user_identities/revoke_access_to_device'>;
type UserIdentitiesRevokeAccessToDeviceResponse = SetNonNullable<Required<RouteResponse<'/user_identities/revoke_access_to_device'>>>;
type UserIdentitiesRevokeAccessToDeviceOptions = never;
type UserIdentitiesUpdateBody = RouteRequestBody<'/user_identities/update'>;
type UserIdentitiesUpdateResponse = SetNonNullable<Required<RouteResponse<'/user_identities/update'>>>;
type UserIdentitiesUpdateOptions = never;

declare class SeamHttpWebhooks {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpWebhooks;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpWebhooks;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpWebhooks;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpWebhooks>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpWebhooks;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpWebhooks;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    create(body?: WebhooksCreateBody): SeamHttpRequest<WebhooksCreateResponse, 'webhook'>;
    delete(body?: WebhooksDeleteParams): SeamHttpRequest<void, undefined>;
    get(body?: WebhooksGetParams): SeamHttpRequest<WebhooksGetResponse, 'webhook'>;
    list(body?: WebhooksListParams): SeamHttpRequest<WebhooksListResponse, 'webhooks'>;
    update(body?: WebhooksUpdateBody): SeamHttpRequest<void, undefined>;
}
type WebhooksCreateBody = RouteRequestBody<'/webhooks/create'>;
type WebhooksCreateResponse = SetNonNullable<Required<RouteResponse<'/webhooks/create'>>>;
type WebhooksCreateOptions = never;
type WebhooksDeleteParams = RouteRequestBody<'/webhooks/delete'>;
type WebhooksDeleteResponse = SetNonNullable<Required<RouteResponse<'/webhooks/delete'>>>;
type WebhooksDeleteOptions = never;
type WebhooksGetParams = RouteRequestBody<'/webhooks/get'>;
type WebhooksGetResponse = SetNonNullable<Required<RouteResponse<'/webhooks/get'>>>;
type WebhooksGetOptions = never;
type WebhooksListParams = RouteRequestBody<'/webhooks/list'>;
type WebhooksListResponse = SetNonNullable<Required<RouteResponse<'/webhooks/list'>>>;
type WebhooksListOptions = never;
type WebhooksUpdateBody = RouteRequestBody<'/webhooks/update'>;
type WebhooksUpdateResponse = SetNonNullable<Required<RouteResponse<'/webhooks/update'>>>;
type WebhooksUpdateOptions = never;

declare class SeamHttpWorkspaces {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpWorkspaces;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpWorkspaces;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpWorkspaces;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpWorkspaces>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpWorkspaces;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpWorkspaces;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    create(body?: WorkspacesCreateBody): SeamHttpRequest<WorkspacesCreateResponse, 'workspace'>;
    get(body?: WorkspacesGetParams): SeamHttpRequest<WorkspacesGetResponse, 'workspace'>;
    list(body?: WorkspacesListParams): SeamHttpRequest<WorkspacesListResponse, 'workspaces'>;
    resetSandbox(body?: WorkspacesResetSandboxBody, options?: Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>): SeamHttpRequest<WorkspacesResetSandboxResponse, 'action_attempt'>;
}
type WorkspacesCreateBody = RouteRequestBody<'/workspaces/create'>;
type WorkspacesCreateResponse = SetNonNullable<Required<RouteResponse<'/workspaces/create'>>>;
type WorkspacesCreateOptions = never;
type WorkspacesGetParams = RouteRequestBody<'/workspaces/get'>;
type WorkspacesGetResponse = SetNonNullable<Required<RouteResponse<'/workspaces/get'>>>;
type WorkspacesGetOptions = never;
type WorkspacesListParams = RouteRequestBody<'/workspaces/list'>;
type WorkspacesListResponse = SetNonNullable<Required<RouteResponse<'/workspaces/list'>>>;
type WorkspacesListOptions = never;
type WorkspacesResetSandboxBody = RouteRequestBody<'/workspaces/reset_sandbox'>;
type WorkspacesResetSandboxResponse = SetNonNullable<Required<RouteResponse<'/workspaces/reset_sandbox'>>>;
type WorkspacesResetSandboxOptions = Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>;

interface ResolveActionAttemptOptions {
    timeout?: number;
    pollingInterval?: number;
}
declare const isSeamActionAttemptError: <T extends {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "LOCK_DOOR";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {};
    action_type: "LOCK_DOOR";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "LOCK_DOOR";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "UNLOCK_DOOR";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {};
    action_type: "UNLOCK_DOOR";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "UNLOCK_DOOR";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "READ_CARD";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {
        acs_credential_id: string | null;
        card_number: string | null;
    };
    action_type: "READ_CARD";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "READ_CARD";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "ENCODE_CARD";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {
        acs_credential_id: string | null;
        card_number: string | null;
    };
    action_type: "ENCODE_CARD";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "ENCODE_CARD";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "RESET_SANDBOX_WORKSPACE";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {};
    action_type: "RESET_SANDBOX_WORKSPACE";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "RESET_SANDBOX_WORKSPACE";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "SET_COOL";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {};
    action_type: "SET_COOL";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "SET_COOL";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "SET_HEAT";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {};
    action_type: "SET_HEAT";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "SET_HEAT";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "SET_HEAT_COOL";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {};
    action_type: "SET_HEAT_COOL";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "SET_HEAT_COOL";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "SET_FAN_MODE";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {};
    action_type: "SET_FAN_MODE";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "SET_FAN_MODE";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "SET_THERMOSTAT_OFF";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {};
    action_type: "SET_THERMOSTAT_OFF";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "SET_THERMOSTAT_OFF";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "ACTIVATE_CLIMATE_PRESET";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {};
    action_type: "ACTIVATE_CLIMATE_PRESET";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "ACTIVATE_CLIMATE_PRESET";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "SYNC_ACCESS_CODES";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    action_type: "SYNC_ACCESS_CODES";
    result?: any;
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "SYNC_ACCESS_CODES";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "CREATE_ACCESS_CODE";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    action_type: "CREATE_ACCESS_CODE";
    result?: any;
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "CREATE_ACCESS_CODE";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "DELETE_ACCESS_CODE";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    action_type: "DELETE_ACCESS_CODE";
    result?: any;
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "DELETE_ACCESS_CODE";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "UPDATE_ACCESS_CODE";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    action_type: "UPDATE_ACCESS_CODE";
    result?: any;
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "UPDATE_ACCESS_CODE";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "CREATE_NOISE_THRESHOLD";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    action_type: "CREATE_NOISE_THRESHOLD";
    result?: any;
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "CREATE_NOISE_THRESHOLD";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "DELETE_NOISE_THRESHOLD";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    action_type: "DELETE_NOISE_THRESHOLD";
    result?: any;
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "DELETE_NOISE_THRESHOLD";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "UPDATE_NOISE_THRESHOLD";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    action_type: "UPDATE_NOISE_THRESHOLD";
    result?: any;
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "UPDATE_NOISE_THRESHOLD";
}>(error: unknown) => error is SeamActionAttemptError<T>;
declare class SeamActionAttemptError<T extends ActionAttempt> extends Error {
    actionAttempt: T;
    constructor(message: string, actionAttempt: T);
}
declare const isSeamActionAttemptFailedError: <T extends {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "LOCK_DOOR";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {};
    action_type: "LOCK_DOOR";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "LOCK_DOOR";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "UNLOCK_DOOR";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {};
    action_type: "UNLOCK_DOOR";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "UNLOCK_DOOR";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "READ_CARD";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {
        acs_credential_id: string | null;
        card_number: string | null;
    };
    action_type: "READ_CARD";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "READ_CARD";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "ENCODE_CARD";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {
        acs_credential_id: string | null;
        card_number: string | null;
    };
    action_type: "ENCODE_CARD";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "ENCODE_CARD";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "RESET_SANDBOX_WORKSPACE";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {};
    action_type: "RESET_SANDBOX_WORKSPACE";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "RESET_SANDBOX_WORKSPACE";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "SET_COOL";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {};
    action_type: "SET_COOL";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "SET_COOL";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "SET_HEAT";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {};
    action_type: "SET_HEAT";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "SET_HEAT";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "SET_HEAT_COOL";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {};
    action_type: "SET_HEAT_COOL";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "SET_HEAT_COOL";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "SET_FAN_MODE";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {};
    action_type: "SET_FAN_MODE";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "SET_FAN_MODE";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "SET_THERMOSTAT_OFF";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {};
    action_type: "SET_THERMOSTAT_OFF";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "SET_THERMOSTAT_OFF";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "ACTIVATE_CLIMATE_PRESET";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {};
    action_type: "ACTIVATE_CLIMATE_PRESET";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "ACTIVATE_CLIMATE_PRESET";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "SYNC_ACCESS_CODES";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    action_type: "SYNC_ACCESS_CODES";
    result?: any;
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "SYNC_ACCESS_CODES";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "CREATE_ACCESS_CODE";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    action_type: "CREATE_ACCESS_CODE";
    result?: any;
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "CREATE_ACCESS_CODE";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "DELETE_ACCESS_CODE";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    action_type: "DELETE_ACCESS_CODE";
    result?: any;
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "DELETE_ACCESS_CODE";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "UPDATE_ACCESS_CODE";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    action_type: "UPDATE_ACCESS_CODE";
    result?: any;
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "UPDATE_ACCESS_CODE";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "CREATE_NOISE_THRESHOLD";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    action_type: "CREATE_NOISE_THRESHOLD";
    result?: any;
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "CREATE_NOISE_THRESHOLD";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "DELETE_NOISE_THRESHOLD";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    action_type: "DELETE_NOISE_THRESHOLD";
    result?: any;
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "DELETE_NOISE_THRESHOLD";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "UPDATE_NOISE_THRESHOLD";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    action_type: "UPDATE_NOISE_THRESHOLD";
    result?: any;
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "UPDATE_NOISE_THRESHOLD";
}>(error: unknown) => error is SeamActionAttemptFailedError<T>;
declare class SeamActionAttemptFailedError<T extends ActionAttempt> extends SeamActionAttemptError<T> {
    code: string;
    constructor(actionAttempt: FailedActionAttempt<T>);
}
declare const isSeamActionAttemptTimeoutError: <T extends {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "LOCK_DOOR";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {};
    action_type: "LOCK_DOOR";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "LOCK_DOOR";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "UNLOCK_DOOR";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {};
    action_type: "UNLOCK_DOOR";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "UNLOCK_DOOR";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "READ_CARD";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {
        acs_credential_id: string | null;
        card_number: string | null;
    };
    action_type: "READ_CARD";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "READ_CARD";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "ENCODE_CARD";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {
        acs_credential_id: string | null;
        card_number: string | null;
    };
    action_type: "ENCODE_CARD";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "ENCODE_CARD";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "RESET_SANDBOX_WORKSPACE";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {};
    action_type: "RESET_SANDBOX_WORKSPACE";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "RESET_SANDBOX_WORKSPACE";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "SET_COOL";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {};
    action_type: "SET_COOL";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "SET_COOL";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "SET_HEAT";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {};
    action_type: "SET_HEAT";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "SET_HEAT";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "SET_HEAT_COOL";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {};
    action_type: "SET_HEAT_COOL";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "SET_HEAT_COOL";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "SET_FAN_MODE";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {};
    action_type: "SET_FAN_MODE";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "SET_FAN_MODE";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "SET_THERMOSTAT_OFF";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {};
    action_type: "SET_THERMOSTAT_OFF";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "SET_THERMOSTAT_OFF";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "ACTIVATE_CLIMATE_PRESET";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    result: {};
    action_type: "ACTIVATE_CLIMATE_PRESET";
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "ACTIVATE_CLIMATE_PRESET";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "SYNC_ACCESS_CODES";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    action_type: "SYNC_ACCESS_CODES";
    result?: any;
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "SYNC_ACCESS_CODES";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "CREATE_ACCESS_CODE";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    action_type: "CREATE_ACCESS_CODE";
    result?: any;
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "CREATE_ACCESS_CODE";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "DELETE_ACCESS_CODE";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    action_type: "DELETE_ACCESS_CODE";
    result?: any;
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "DELETE_ACCESS_CODE";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "UPDATE_ACCESS_CODE";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    action_type: "UPDATE_ACCESS_CODE";
    result?: any;
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "UPDATE_ACCESS_CODE";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "CREATE_NOISE_THRESHOLD";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    action_type: "CREATE_NOISE_THRESHOLD";
    result?: any;
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "CREATE_NOISE_THRESHOLD";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "DELETE_NOISE_THRESHOLD";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    action_type: "DELETE_NOISE_THRESHOLD";
    result?: any;
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "DELETE_NOISE_THRESHOLD";
} | {
    error: null;
    status: "pending";
    action_attempt_id: string;
    result: null;
    action_type: "UPDATE_NOISE_THRESHOLD";
} | {
    error: null;
    status: "success";
    action_attempt_id: string;
    action_type: "UPDATE_NOISE_THRESHOLD";
    result?: any;
} | {
    error: {
        type: string;
        message: string;
    };
    status: "error";
    action_attempt_id: string;
    result: null;
    action_type: "UPDATE_NOISE_THRESHOLD";
}>(error: unknown) => error is SeamActionAttemptTimeoutError<T>;
declare class SeamActionAttemptTimeoutError<T extends ActionAttempt> extends SeamActionAttemptError<T> {
    constructor(actionAttempt: T, timeout: number);
}
type FailedActionAttempt<T extends ActionAttempt> = Extract<T, {
    status: 'error';
}>;

type SeamHttpMultiWorkspaceOptions = SeamHttpMultiWorkspaceOptionsWithClient | SeamHttpMultiWorkspaceOptionsWithConsoleSessionToken | SeamHttpMultiWorkspaceOptionsWithPersonalAccessToken;
type SeamHttpOptions = SeamHttpOptionsFromEnv | SeamHttpOptionsWithClient | SeamHttpOptionsWithApiKey | SeamHttpOptionsWithClientSessionToken | SeamHttpOptionsWithConsoleSessionToken | SeamHttpOptionsWithPersonalAccessToken;
interface SeamHttpCommonOptions extends ClientOptions, SeamHttpRequestOptions {
    endpoint?: string;
}
interface SeamHttpRequestOptions {
    waitForActionAttempt?: boolean | ResolveActionAttemptOptions;
}
interface SeamHttpFromPublishableKeyOptions extends SeamHttpCommonOptions {
}
interface SeamHttpOptionsFromEnv extends SeamHttpCommonOptions {
}
interface SeamHttpMultiWorkspaceOptionsWithClient extends SeamHttpRequestOptions {
    client: Client;
}
declare const isSeamHttpMultiWorkspaceOptionsWithClient: (options: SeamHttpOptions) => options is SeamHttpMultiWorkspaceOptionsWithClient;
interface SeamHttpOptionsWithClient extends SeamHttpRequestOptions {
    client: Client;
}
declare const isSeamHttpOptionsWithClient: (options: SeamHttpOptions) => options is SeamHttpOptionsWithClient;
interface SeamHttpOptionsWithApiKey extends SeamHttpCommonOptions {
    apiKey: string;
}
declare const isSeamHttpOptionsWithApiKey: (options: SeamHttpOptions) => options is SeamHttpOptionsWithApiKey;
interface SeamHttpOptionsWithClientSessionToken extends SeamHttpCommonOptions {
    clientSessionToken: string;
}
declare const isSeamHttpOptionsWithClientSessionToken: (options: SeamHttpOptions) => options is SeamHttpOptionsWithClientSessionToken;
interface SeamHttpMultiWorkspaceOptionsWithConsoleSessionToken extends SeamHttpCommonOptions {
    consoleSessionToken: string;
}
declare const isSeamHttpMultiWorkspaceOptionsWithConsoleSessionToken: (options: SeamHttpOptions) => options is SeamHttpMultiWorkspaceOptionsWithConsoleSessionToken;
interface SeamHttpOptionsWithConsoleSessionToken extends SeamHttpCommonOptions {
    consoleSessionToken: string;
    workspaceId: string;
}
declare const isSeamHttpOptionsWithConsoleSessionToken: (options: SeamHttpOptions) => options is SeamHttpOptionsWithConsoleSessionToken;
interface SeamHttpMultiWorkspaceOptionsWithPersonalAccessToken extends SeamHttpCommonOptions {
    personalAccessToken: string;
}
declare const isSeamHttpMultiWorkspaceOptionsWithPersonalAccessToken: (options: SeamHttpOptions) => options is SeamHttpMultiWorkspaceOptionsWithPersonalAccessToken;
interface SeamHttpOptionsWithPersonalAccessToken extends SeamHttpCommonOptions {
    personalAccessToken: string;
    workspaceId: string;
}
declare const isSeamHttpOptionsWithPersonalAccessToken: (options: SeamHttpOptions) => options is SeamHttpOptionsWithPersonalAccessToken;
declare class SeamHttpInvalidOptionsError extends Error {
    constructor(message: string);
}
declare class SeamHttpMultiWorkspaceInvalidOptionsError extends Error {
    constructor(message: string);
}

declare class SeamHttpInvalidTokenError extends Error {
    constructor(message: string);
}

declare const errorInterceptor: (err: unknown) => Promise<void>;

declare const getOpenapiSchema: (endpoint?: string) => Promise<typeof openapi>;

declare class SeamHttp {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    readonly ltsVersion = "1.0.0";
    static ltsVersion: string;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttp;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttp;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttp;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttp>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttp;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttp;
    updateClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken']): Promise<void>;
    get accessCodes(): SeamHttpAccessCodes;
    get acs(): SeamHttpAcs;
    get actionAttempts(): SeamHttpActionAttempts;
    get clientSessions(): SeamHttpClientSessions;
    get connectedAccounts(): SeamHttpConnectedAccounts;
    get connectWebviews(): SeamHttpConnectWebviews;
    get devices(): SeamHttpDevices;
    get events(): SeamHttpEvents;
    get locks(): SeamHttpLocks;
    get networks(): SeamHttpNetworks;
    get noiseSensors(): SeamHttpNoiseSensors;
    get phones(): SeamHttpPhones;
    get thermostats(): SeamHttpThermostats;
    get userIdentities(): SeamHttpUserIdentities;
    get webhooks(): SeamHttpWebhooks;
    get workspaces(): Omit<SeamHttpWorkspaces, 'create'>;
}

interface ApiError {
    type: string;
    message: string;
    data?: unknown;
    validation_errors?: Record<string, {
        _errors: string[];
    }>;
}

declare class SeamHttpApiError extends Error {
    code: string;
    statusCode: number;
    requestId: string;
    data?: unknown;
    constructor(error: ApiError, statusCode: number, requestId: string);
}
declare const isSeamHttpApiError: (error: unknown) => error is SeamHttpApiError;
declare class SeamHttpUnauthorizedError extends SeamHttpApiError {
    code: 'unauthorized';
    statusCode: 401;
    constructor(requestId: string);
}
declare const isSeamHttpUnauthorizedError: (error: unknown) => error is SeamHttpUnauthorizedError;
declare class SeamHttpInvalidInputError extends SeamHttpApiError {
    #private;
    code: 'invalid_input';
    constructor(error: ApiError, statusCode: number, requestId: string);
    getValidationErrorMessages(paramName: string): string[];
}
declare const isSeamHttpInvalidInputError: (error: unknown) => error is SeamHttpInvalidInputError;

declare class SeamHttpMultiWorkspace {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(options: SeamHttpMultiWorkspaceOptions);
    static fromClient(client: SeamHttpMultiWorkspaceOptionsWithClient['client'], options?: Omit<SeamHttpMultiWorkspaceOptionsWithClient, 'client'>): SeamHttpMultiWorkspace;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpMultiWorkspaceOptionsWithConsoleSessionToken['consoleSessionToken'], options?: Omit<SeamHttpMultiWorkspaceOptionsWithConsoleSessionToken, 'consoleSessionToken'>): SeamHttpMultiWorkspace;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpMultiWorkspaceOptionsWithPersonalAccessToken['personalAccessToken'], options?: Omit<SeamHttpMultiWorkspaceOptionsWithPersonalAccessToken, 'personalAccessToken'>): SeamHttpMultiWorkspace;
    get workspaces(): Pick<SeamHttpWorkspaces, 'create' | 'list'>;
}

declare const isApiKey: (token: string) => boolean;
declare const isClientSessionToken: (token: string) => boolean;
declare const isPublishableKey: (token: string) => boolean;
declare const isConsoleSessionToken: (token: string) => boolean;
declare const isPersonalAccessToken: (token: string) => boolean;

export { type AccessCodesCreateBody, type AccessCodesCreateMultipleBody, type AccessCodesCreateMultipleOptions, type AccessCodesCreateMultipleResponse, type AccessCodesCreateOptions, type AccessCodesCreateResponse, type AccessCodesDeleteOptions, type AccessCodesDeleteParams, type AccessCodesDeleteResponse, type AccessCodesGenerateCodeBody, type AccessCodesGenerateCodeOptions, type AccessCodesGenerateCodeResponse, type AccessCodesGetOptions, type AccessCodesGetParams, type AccessCodesGetResponse, type AccessCodesListOptions, type AccessCodesListParams, type AccessCodesListResponse, type AccessCodesPullBackupAccessCodeBody, type AccessCodesPullBackupAccessCodeOptions, type AccessCodesPullBackupAccessCodeResponse, type AccessCodesSimulateCreateUnmanagedAccessCodeBody, type AccessCodesSimulateCreateUnmanagedAccessCodeOptions, type AccessCodesSimulateCreateUnmanagedAccessCodeResponse, type AccessCodesUnmanagedConvertToManagedBody, type AccessCodesUnmanagedConvertToManagedOptions, type AccessCodesUnmanagedConvertToManagedResponse, type AccessCodesUnmanagedDeleteOptions, type AccessCodesUnmanagedDeleteParams, type AccessCodesUnmanagedDeleteResponse, type AccessCodesUnmanagedGetOptions, type AccessCodesUnmanagedGetParams, type AccessCodesUnmanagedGetResponse, type AccessCodesUnmanagedListOptions, type AccessCodesUnmanagedListParams, type AccessCodesUnmanagedListResponse, type AccessCodesUnmanagedUpdateBody, type AccessCodesUnmanagedUpdateOptions, type AccessCodesUnmanagedUpdateResponse, type AccessCodesUpdateBody, type AccessCodesUpdateOptions, type AccessCodesUpdateResponse, type AcsAccessGroupsAddUserBody, type AcsAccessGroupsAddUserOptions, type AcsAccessGroupsAddUserResponse, type AcsAccessGroupsGetOptions, type AcsAccessGroupsGetParams, type AcsAccessGroupsGetResponse, type AcsAccessGroupsListAccessibleEntrancesOptions, type AcsAccessGroupsListAccessibleEntrancesParams, type AcsAccessGroupsListAccessibleEntrancesResponse, type AcsAccessGroupsListOptions, type AcsAccessGroupsListParams, type AcsAccessGroupsListResponse, type AcsAccessGroupsListUsersOptions, type AcsAccessGroupsListUsersParams, type AcsAccessGroupsListUsersResponse, type AcsAccessGroupsRemoveUserOptions, type AcsAccessGroupsRemoveUserParams, type AcsAccessGroupsRemoveUserResponse, type AcsAccessGroupsUnmanagedGetOptions, type AcsAccessGroupsUnmanagedGetParams, type AcsAccessGroupsUnmanagedGetResponse, type AcsAccessGroupsUnmanagedListOptions, type AcsAccessGroupsUnmanagedListParams, type AcsAccessGroupsUnmanagedListResponse, type AcsCredentialPoolsListOptions, type AcsCredentialPoolsListParams, type AcsCredentialPoolsListResponse, type AcsCredentialProvisioningAutomationsLaunchBody, type AcsCredentialProvisioningAutomationsLaunchOptions, type AcsCredentialProvisioningAutomationsLaunchResponse, type AcsCredentialsAssignBody, type AcsCredentialsAssignOptions, type AcsCredentialsAssignResponse, type AcsCredentialsCreateBody, type AcsCredentialsCreateOptions, type AcsCredentialsCreateResponse, type AcsCredentialsDeleteOptions, type AcsCredentialsDeleteParams, type AcsCredentialsDeleteResponse, type AcsCredentialsGetOptions, type AcsCredentialsGetParams, type AcsCredentialsGetResponse, type AcsCredentialsListAccessibleEntrancesOptions, type AcsCredentialsListAccessibleEntrancesParams, type AcsCredentialsListAccessibleEntrancesResponse, type AcsCredentialsListOptions, type AcsCredentialsListParams, type AcsCredentialsListResponse, type AcsCredentialsUnassignBody, type AcsCredentialsUnassignOptions, type AcsCredentialsUnassignResponse, type AcsCredentialsUnmanagedGetOptions, type AcsCredentialsUnmanagedGetParams, type AcsCredentialsUnmanagedGetResponse, type AcsCredentialsUnmanagedListOptions, type AcsCredentialsUnmanagedListParams, type AcsCredentialsUnmanagedListResponse, type AcsCredentialsUpdateBody, type AcsCredentialsUpdateOptions, type AcsCredentialsUpdateResponse, type AcsEncodersEncodeCardBody, type AcsEncodersEncodeCardOptions, type AcsEncodersEncodeCardResponse, type AcsEncodersListOptions, type AcsEncodersListParams, type AcsEncodersListResponse, type AcsEncodersReadCardBody, type AcsEncodersReadCardOptions, type AcsEncodersReadCardResponse, type AcsEntrancesGetOptions, type AcsEntrancesGetParams, type AcsEntrancesGetResponse, type AcsEntrancesGrantAccessBody, type AcsEntrancesGrantAccessOptions, type AcsEntrancesGrantAccessResponse, type AcsEntrancesListCredentialsWithAccessOptions, type AcsEntrancesListCredentialsWithAccessParams, type AcsEntrancesListCredentialsWithAccessResponse, type AcsEntrancesListOptions, type AcsEntrancesListParams, type AcsEntrancesListResponse, type AcsSystemsGetOptions, type AcsSystemsGetParams, type AcsSystemsGetResponse, type AcsSystemsListCompatibleCredentialManagerAcsSystemsOptions, type AcsSystemsListCompatibleCredentialManagerAcsSystemsParams, type AcsSystemsListCompatibleCredentialManagerAcsSystemsResponse, type AcsSystemsListOptions, type AcsSystemsListParams, type AcsSystemsListResponse, type AcsUsersAddToAccessGroupBody, type AcsUsersAddToAccessGroupOptions, type AcsUsersAddToAccessGroupResponse, type AcsUsersCreateBody, type AcsUsersCreateOptions, type AcsUsersCreateResponse, type AcsUsersDeleteOptions, type AcsUsersDeleteParams, type AcsUsersDeleteResponse, type AcsUsersGetOptions, type AcsUsersGetParams, type AcsUsersGetResponse, type AcsUsersListAccessibleEntrancesOptions, type AcsUsersListAccessibleEntrancesParams, type AcsUsersListAccessibleEntrancesResponse, type AcsUsersListOptions, type AcsUsersListParams, type AcsUsersListResponse, type AcsUsersRemoveFromAccessGroupOptions, type AcsUsersRemoveFromAccessGroupParams, type AcsUsersRemoveFromAccessGroupResponse, type AcsUsersRevokeAccessToAllEntrancesOptions, type AcsUsersRevokeAccessToAllEntrancesParams, type AcsUsersRevokeAccessToAllEntrancesResponse, type AcsUsersSuspendBody, type AcsUsersSuspendOptions, type AcsUsersSuspendResponse, type AcsUsersUnmanagedGetOptions, type AcsUsersUnmanagedGetParams, type AcsUsersUnmanagedGetResponse, type AcsUsersUnmanagedListOptions, type AcsUsersUnmanagedListParams, type AcsUsersUnmanagedListResponse, type AcsUsersUnsuspendBody, type AcsUsersUnsuspendOptions, type AcsUsersUnsuspendResponse, type AcsUsersUpdateBody, type AcsUsersUpdateOptions, type AcsUsersUpdateResponse, type ActionAttemptsGetOptions, type ActionAttemptsGetParams, type ActionAttemptsGetResponse, type ActionAttemptsListOptions, type ActionAttemptsListParams, type ActionAttemptsListResponse, type ClientSessionsCreateBody, type ClientSessionsCreateOptions, type ClientSessionsCreateResponse, type ClientSessionsDeleteOptions, type ClientSessionsDeleteParams, type ClientSessionsDeleteResponse, type ClientSessionsGetOptions, type ClientSessionsGetOrCreateBody, type ClientSessionsGetOrCreateOptions, type ClientSessionsGetOrCreateResponse, type ClientSessionsGetParams, type ClientSessionsGetResponse, type ClientSessionsGrantAccessBody, type ClientSessionsGrantAccessOptions, type ClientSessionsGrantAccessResponse, type ClientSessionsListOptions, type ClientSessionsListParams, type ClientSessionsListResponse, type ClientSessionsRevokeOptions, type ClientSessionsRevokeParams, type ClientSessionsRevokeResponse, type ConnectWebviewsCreateBody, type ConnectWebviewsCreateOptions, type ConnectWebviewsCreateResponse, type ConnectWebviewsDeleteOptions, type ConnectWebviewsDeleteParams, type ConnectWebviewsDeleteResponse, type ConnectWebviewsGetOptions, type ConnectWebviewsGetParams, type ConnectWebviewsGetResponse, type ConnectWebviewsListOptions, type ConnectWebviewsListParams, type ConnectWebviewsListResponse, type ConnectedAccountsDeleteOptions, type ConnectedAccountsDeleteParams, type ConnectedAccountsDeleteResponse, type ConnectedAccountsGetOptions, type ConnectedAccountsGetParams, type ConnectedAccountsGetResponse, type ConnectedAccountsListOptions, type ConnectedAccountsListParams, type ConnectedAccountsListResponse, type ConnectedAccountsUpdateBody, type ConnectedAccountsUpdateOptions, type ConnectedAccountsUpdateResponse, type DevicesDeleteOptions, type DevicesDeleteParams, type DevicesDeleteResponse, type DevicesGetOptions, type DevicesGetParams, type DevicesGetResponse, type DevicesListDeviceProvidersOptions, type DevicesListDeviceProvidersParams, type DevicesListDeviceProvidersResponse, type DevicesListOptions, type DevicesListParams, type DevicesListResponse, type DevicesSimulateConnectBody, type DevicesSimulateConnectOptions, type DevicesSimulateConnectResponse, type DevicesSimulateDisconnectBody, type DevicesSimulateDisconnectOptions, type DevicesSimulateDisconnectResponse, type DevicesSimulateRemoveOptions, type DevicesSimulateRemoveParams, type DevicesSimulateRemoveResponse, type DevicesUnmanagedGetOptions, type DevicesUnmanagedGetParams, type DevicesUnmanagedGetResponse, type DevicesUnmanagedListOptions, type DevicesUnmanagedListParams, type DevicesUnmanagedListResponse, type DevicesUnmanagedUpdateBody, type DevicesUnmanagedUpdateOptions, type DevicesUnmanagedUpdateResponse, type DevicesUpdateBody, type DevicesUpdateOptions, type DevicesUpdateResponse, type EventsGetOptions, type EventsGetParams, type EventsGetResponse, type EventsListOptions, type EventsListParams, type EventsListResponse, type LocksGetOptions, type LocksGetParams, type LocksGetResponse, type LocksListOptions, type LocksListParams, type LocksListResponse, type LocksLockDoorBody, type LocksLockDoorOptions, type LocksLockDoorResponse, type LocksUnlockDoorBody, type LocksUnlockDoorOptions, type LocksUnlockDoorResponse, type NetworksGetOptions, type NetworksGetParams, type NetworksGetResponse, type NetworksListOptions, type NetworksListParams, type NetworksListResponse, type NoiseSensorsListOptions, type NoiseSensorsListParams, type NoiseSensorsListResponse, type NoiseSensorsNoiseThresholdsCreateBody, type NoiseSensorsNoiseThresholdsCreateOptions, type NoiseSensorsNoiseThresholdsCreateResponse, type NoiseSensorsNoiseThresholdsDeleteOptions, type NoiseSensorsNoiseThresholdsDeleteParams, type NoiseSensorsNoiseThresholdsDeleteResponse, type NoiseSensorsNoiseThresholdsGetOptions, type NoiseSensorsNoiseThresholdsGetParams, type NoiseSensorsNoiseThresholdsGetResponse, type NoiseSensorsNoiseThresholdsListOptions, type NoiseSensorsNoiseThresholdsListParams, type NoiseSensorsNoiseThresholdsListResponse, type NoiseSensorsNoiseThresholdsUpdateBody, type NoiseSensorsNoiseThresholdsUpdateOptions, type NoiseSensorsNoiseThresholdsUpdateResponse, type NoiseSensorsSimulateTriggerNoiseThresholdBody, type NoiseSensorsSimulateTriggerNoiseThresholdOptions, type NoiseSensorsSimulateTriggerNoiseThresholdResponse, type PhonesDeactivateOptions, type PhonesDeactivateParams, type PhonesDeactivateResponse, type PhonesListOptions, type PhonesListParams, type PhonesListResponse, type PhonesSimulateCreateSandboxPhoneBody, type PhonesSimulateCreateSandboxPhoneOptions, type PhonesSimulateCreateSandboxPhoneResponse, SeamActionAttemptError, SeamActionAttemptFailedError, SeamActionAttemptTimeoutError, SeamHttp, SeamHttpAccessCodes, SeamHttpAccessCodesSimulate, SeamHttpAccessCodesUnmanaged, SeamHttpAcs, SeamHttpAcsAccessGroups, SeamHttpAcsAccessGroupsUnmanaged, SeamHttpAcsCredentialPools, SeamHttpAcsCredentialProvisioningAutomations, SeamHttpAcsCredentials, SeamHttpAcsCredentialsUnmanaged, SeamHttpAcsEncoders, SeamHttpAcsEntrances, SeamHttpAcsSystems, SeamHttpAcsUsers, SeamHttpAcsUsersUnmanaged, SeamHttpActionAttempts, SeamHttpApiError, SeamHttpClientSessions, SeamHttpConnectWebviews, SeamHttpConnectedAccounts, SeamHttpDevices, SeamHttpDevicesSimulate, SeamHttpDevicesUnmanaged, SeamHttpEvents, type SeamHttpFromPublishableKeyOptions, SeamHttpInvalidInputError, SeamHttpInvalidOptionsError, SeamHttpInvalidTokenError, SeamHttpLocks, SeamHttpMultiWorkspace, SeamHttpMultiWorkspaceInvalidOptionsError, type SeamHttpMultiWorkspaceOptions, type SeamHttpMultiWorkspaceOptionsWithClient, type SeamHttpMultiWorkspaceOptionsWithConsoleSessionToken, type SeamHttpMultiWorkspaceOptionsWithPersonalAccessToken, SeamHttpNetworks, SeamHttpNoiseSensors, SeamHttpNoiseSensorsNoiseThresholds, SeamHttpNoiseSensorsSimulate, type SeamHttpOptions, type SeamHttpOptionsFromEnv, type SeamHttpOptionsWithApiKey, type SeamHttpOptionsWithClient, type SeamHttpOptionsWithClientSessionToken, type SeamHttpOptionsWithConsoleSessionToken, type SeamHttpOptionsWithPersonalAccessToken, SeamHttpPhones, SeamHttpPhonesSimulate, SeamHttpRequest, type SeamHttpRequestOptions, SeamHttpThermostats, SeamHttpThermostatsSchedules, SeamHttpUnauthorizedError, SeamHttpUserIdentities, SeamHttpUserIdentitiesEnrollmentAutomations, SeamHttpWebhooks, SeamHttpWorkspaces, type ThermostatsActivateClimatePresetBody, type ThermostatsActivateClimatePresetOptions, type ThermostatsActivateClimatePresetResponse, type ThermostatsCoolBody, type ThermostatsCoolOptions, type ThermostatsCoolResponse, type ThermostatsCreateClimatePresetBody, type ThermostatsCreateClimatePresetOptions, type ThermostatsCreateClimatePresetResponse, type ThermostatsDeleteClimatePresetBody, type ThermostatsDeleteClimatePresetOptions, type ThermostatsDeleteClimatePresetResponse, type ThermostatsGetOptions, type ThermostatsGetParams, type ThermostatsGetResponse, type ThermostatsHeatBody, type ThermostatsHeatCoolBody, type ThermostatsHeatCoolOptions, type ThermostatsHeatCoolResponse, type ThermostatsHeatOptions, type ThermostatsHeatResponse, type ThermostatsListOptions, type ThermostatsListParams, type ThermostatsListResponse, type ThermostatsOffBody, type ThermostatsOffOptions, type ThermostatsOffResponse, type ThermostatsSchedulesCreateBody, type ThermostatsSchedulesCreateOptions, type ThermostatsSchedulesCreateResponse, type ThermostatsSchedulesDeleteOptions, type ThermostatsSchedulesDeleteParams, type ThermostatsSchedulesDeleteResponse, type ThermostatsSchedulesGetOptions, type ThermostatsSchedulesGetParams, type ThermostatsSchedulesGetResponse, type ThermostatsSchedulesListOptions, type ThermostatsSchedulesListParams, type ThermostatsSchedulesListResponse, type ThermostatsSchedulesUpdateBody, type ThermostatsSchedulesUpdateOptions, type ThermostatsSchedulesUpdateResponse, type ThermostatsSetFallbackClimatePresetBody, type ThermostatsSetFallbackClimatePresetOptions, type ThermostatsSetFallbackClimatePresetResponse, type ThermostatsSetFanModeBody, type ThermostatsSetFanModeOptions, type ThermostatsSetFanModeResponse, type ThermostatsUpdateClimatePresetBody, type ThermostatsUpdateClimatePresetOptions, type ThermostatsUpdateClimatePresetResponse, type UserIdentitiesAddAcsUserBody, type UserIdentitiesAddAcsUserOptions, type UserIdentitiesAddAcsUserResponse, type UserIdentitiesCreateBody, type UserIdentitiesCreateOptions, type UserIdentitiesCreateResponse, type UserIdentitiesDeleteOptions, type UserIdentitiesDeleteParams, type UserIdentitiesDeleteResponse, type UserIdentitiesEnrollmentAutomationsDeleteOptions, type UserIdentitiesEnrollmentAutomationsDeleteParams, type UserIdentitiesEnrollmentAutomationsDeleteResponse, type UserIdentitiesEnrollmentAutomationsGetOptions, type UserIdentitiesEnrollmentAutomationsGetParams, type UserIdentitiesEnrollmentAutomationsGetResponse, type UserIdentitiesEnrollmentAutomationsLaunchBody, type UserIdentitiesEnrollmentAutomationsLaunchOptions, type UserIdentitiesEnrollmentAutomationsLaunchResponse, type UserIdentitiesEnrollmentAutomationsListOptions, type UserIdentitiesEnrollmentAutomationsListParams, type UserIdentitiesEnrollmentAutomationsListResponse, type UserIdentitiesGetOptions, type UserIdentitiesGetParams, type UserIdentitiesGetResponse, type UserIdentitiesGrantAccessToDeviceBody, type UserIdentitiesGrantAccessToDeviceOptions, type UserIdentitiesGrantAccessToDeviceResponse, type UserIdentitiesListAccessibleDevicesOptions, type UserIdentitiesListAccessibleDevicesParams, type UserIdentitiesListAccessibleDevicesResponse, type UserIdentitiesListAcsSystemsOptions, type UserIdentitiesListAcsSystemsParams, type UserIdentitiesListAcsSystemsResponse, type UserIdentitiesListAcsUsersOptions, type UserIdentitiesListAcsUsersParams, type UserIdentitiesListAcsUsersResponse, type UserIdentitiesListOptions, type UserIdentitiesListParams, type UserIdentitiesListResponse, type UserIdentitiesRemoveAcsUserOptions, type UserIdentitiesRemoveAcsUserParams, type UserIdentitiesRemoveAcsUserResponse, type UserIdentitiesRevokeAccessToDeviceOptions, type UserIdentitiesRevokeAccessToDeviceParams, type UserIdentitiesRevokeAccessToDeviceResponse, type UserIdentitiesUpdateBody, type UserIdentitiesUpdateOptions, type UserIdentitiesUpdateResponse, type WebhooksCreateBody, type WebhooksCreateOptions, type WebhooksCreateResponse, type WebhooksDeleteOptions, type WebhooksDeleteParams, type WebhooksDeleteResponse, type WebhooksGetOptions, type WebhooksGetParams, type WebhooksGetResponse, type WebhooksListOptions, type WebhooksListParams, type WebhooksListResponse, type WebhooksUpdateBody, type WebhooksUpdateOptions, type WebhooksUpdateResponse, type WorkspacesCreateBody, type WorkspacesCreateOptions, type WorkspacesCreateResponse, type WorkspacesGetOptions, type WorkspacesGetParams, type WorkspacesGetResponse, type WorkspacesListOptions, type WorkspacesListParams, type WorkspacesListResponse, type WorkspacesResetSandboxBody, type WorkspacesResetSandboxOptions, type WorkspacesResetSandboxResponse, errorInterceptor, getOpenapiSchema, isApiKey, isClientSessionToken, isConsoleSessionToken, isPersonalAccessToken, isPublishableKey, isSeamActionAttemptError, isSeamActionAttemptFailedError, isSeamActionAttemptTimeoutError, isSeamHttpApiError, isSeamHttpInvalidInputError, isSeamHttpMultiWorkspaceOptionsWithClient, isSeamHttpMultiWorkspaceOptionsWithConsoleSessionToken, isSeamHttpMultiWorkspaceOptionsWithPersonalAccessToken, isSeamHttpOptionsWithApiKey, isSeamHttpOptionsWithClient, isSeamHttpOptionsWithClientSessionToken, isSeamHttpOptionsWithConsoleSessionToken, isSeamHttpOptionsWithPersonalAccessToken, isSeamHttpUnauthorizedError };
